<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Live Grading Assistant - Pacifica Christian</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            'pacifica-navy': '#092f57',
            'pacifica-orange': '#e55204',
            'pacifica-gray': '#cbc3ba',
            'pacifica-slate': '#597d95',
            'pacifica-midnight': '#093c71',
            'pacifica-robin': '#0091b2',
            'pacifica-canary': '#f5be0b',
            'pacifica-tangerine': '#f18c20'
          },
          fontFamily: {
            'gotham': ['Gotham', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Arial', 'sans-serif']
          },
          animation: {
            'fadeIn': 'fadeIn 0.3s ease-in-out'
          },
          keyframes: {
            fadeIn: {
              '0%': { opacity: '0', transform: 'scale(0.95)' },
              '100%': { opacity: '1', transform: 'scale(1)' }
            }
          }
        }
      }
    }
  </script>
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    body {
      font-family: 'Gotham', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    }

    /* Minimal button kit (brand-aware) */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: .5rem;
      padding: .5rem .75rem;
      border: 1px solid rgba(9, 60, 113, 0.28);
      /* pacifica-midnight tint */
      border-radius: .5rem;
      background: #fff;
      color: #093c71;
      /* pacifica-midnight */
      font-weight: 600;
      line-height: 1.2;
      transition: background-color 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
      text-align: center;
    }

    .btn:hover {
      background: rgba(241, 140, 32, .08);
      border-color: rgba(241, 140, 32, .45);
    }

    .btn:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(241, 140, 32, .35);
    }

    .btn:disabled {
      opacity: .5;
      cursor: not-allowed;
    }

    .btn-primary {
      background: #f18c20;
      /* pacifica-tangerine */
      color: #fff;
      border-color: #f18c20;
    }

    .btn-primary:hover {
      background: #e55204;
      border-color: #e55204;
    }

    /* pacifica-orange */

    .btn-outline {
      background: #fff;
      color: #093c71;
      border-color: rgba(9, 60, 113, 0.28);
    }

    .btn-danger {
      background: #e03131;
      color: #fff;
      border-color: #e03131;
    }

    .btn-danger:hover {
      background: #c92a2a;
      border-color: #c92a2a;
    }

    /* Light global normalization for any <button> not using .btn */
    button {
      box-shadow: none;
    }

    button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(241, 140, 32, .35);
    }

    /* Spreadsheet-like table styles */
    .spreadsheet-table {
      border-collapse: separate;
      border-spacing: 0;
      user-select: none;
    }

    .spreadsheet-table th,
    .spreadsheet-table td {
      border: 1px solid #e5e7eb;
      position: relative;
    }

    .spreadsheet-table th {
      background: #f3f4f6;
      font-weight: 600;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .spreadsheet-table td {
      background: white;
      cursor: cell;
    }

    .spreadsheet-table td.selected-cell {
      background: #dbeafe !important;
      outline: 2px solid #3b82f6;
      outline-offset: -2px;
      z-index: 5;
    }

    .spreadsheet-table td.column-selected {
      background: #eff6ff !important;
    }

    .spreadsheet-table td.row-selected {
      background: #f0fdf4 !important;
    }

    .spreadsheet-table th.column-header-selected {
      background: #bfdbfe !important;
    }

    .spreadsheet-table input {
      border: none !important;
      background: transparent !important;
      width: 100%;
      padding: 0;
      outline: none !important;
      box-shadow: none !important;
    }

    .spreadsheet-table input:focus {
      outline: none !important;
      box-shadow: none !important;
      ring: 0 !important;
    }

    .spreadsheet-table td:focus-within {
      outline: 2px solid #3b82f6;
      outline-offset: -2px;
      z-index: 5;
    }

    .cell-content {
      min-height: 1.5rem;
      padding: 0.5rem;
      user-select: text;
    }

    .cell-content:focus {
      outline: 2px solid #3b82f6;
      outline-offset: -2px;
    }

    /* Column resize handle */
    .resize-handle {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      cursor: col-resize;
      background: transparent;
    }

    .resize-handle:hover {
      background: #3b82f6;
    }
  </style>
</head>

<body class="bg-pacifica-gray bg-opacity-10">
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
    const { useState, useEffect, useRef, useMemo, useCallback } = React;

    const WEBHOOK_TIMEOUT_MINUTES = 10;
    const WEBHOOK_TIMEOUT_MS = WEBHOOK_TIMEOUT_MINUTES * 60 * 1000;

    const fetchWithTimeout = async (url, options = {}, timeoutMs = WEBHOOK_TIMEOUT_MS) => {
      const { signal: userSignal, ...rest } = options || {};
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

      if (userSignal) {
        if (userSignal.aborted) {
          controller.abort();
        } else {
          userSignal.addEventListener('abort', () => controller.abort(), { once: true });
        }
      }

      try {
        return await fetch(url, { ...rest, signal: controller.signal });
      } finally {
        clearTimeout(timeoutId);
      }
    };

    const normalizeWebhookResult = (result, logPrefix) => {
      let studentsData = [];

      if (Array.isArray(result) && result.length > 0 && result[0].data && Array.isArray(result[0].data)) {
        studentsData = result[0].data;
        console.log(`${logPrefix} Received n8n aggregate format with ${studentsData.length} student(s)`);
      }
      else if (Array.isArray(result) && result.length > 0 && result[0].studentName) {
        studentsData = result;
        console.log(`${logPrefix} Received direct array with ${studentsData.length} student(s)`);
      }
      else if (result && result.students && Array.isArray(result.students)) {
        studentsData = result.students;
        console.log(`${logPrefix} Received object format with ${studentsData.length} student(s)`);
      }
      else if (result && result.studentName && result.scores) {
        studentsData = [result];
        console.log(`${logPrefix} Received single student`);
      }
      else if (result && result.data && Array.isArray(result.data)) {
        studentsData = result.data;
        console.log(`${logPrefix} Received n8n object format with ${studentsData.length} student(s)`);
      }
      else if (Array.isArray(result) && result.length === 0) {
        studentsData = [];
        console.log(`${logPrefix} Received empty array`);
      }
      else {
        console.log(`${logPrefix} ⚠️ Unrecognized format:`, result);
      }

      console.log(`${logPrefix} Parsed ${studentsData.length} student(s) for processing`);
      return studentsData;
    };

    const CONFIG = {
      AIRTABLE_API_KEY: 'patCUB0HwqgJr9nOr.d93cc816ba0e0dc0c22bbe5eaada139d84f864256b401446d1c2726da1247b4f',
      AIRTABLE_BASE_ID: 'appTwYDVvnYPB8D2N',
      N8N_WEBHOOK_URL: 'https://kringuette0.app.n8n.cloud/webhook/voice-grader',
      N8N_TRANSCRIPT_WEBHOOK_URL: 'https://kringuette0.app.n8n.cloud/webhook/77f1b709-51b2-4d7f-9d99-b9c8bf063725',
      N8N_EMAIL_WEBHOOK_URL: 'https://kringuette0.app.n8n.cloud/webhook/80869e6a-5041-41e7-a35d-de6da27193e3',
      MANUAL_TRANSCRIPT_RESULT_PATH: '/manual-transcript-callback',
      TABLES: {
        TEACHERS: 'Teachers',
        SECTIONS: 'Master Sections',
        STUDENTS: 'Student Roster',
        GRADES: 'Grades',
        GRADE_SCORES: 'Grade Scores',
        RUBRICS: 'Rubrics',
      },
      FIELDS: {
        TEACHERS: { NAME: 'Name', EMAIL: 'Email', FIRST_NAME: 'First Name', LAST_NAME: 'Last Name', SECTIONS: 'Master Sections' },
        SECTIONS: { NAME: 'Section Name', SECTION_ID: 'Section ID', TEACHER_LINK: 'Teacher Link', STUDENT_ROSTER: 'Student Roster' },
        STUDENTS: { NAME: 'Name', EMAIL: 'Email', ID: 'ID', SECTIONS: 'Master Sections' },
        GRADES: { ASSIGNMENT: 'Assignment', STUDENT: 'Student', COMMENTS: 'Comments', FINAL_GRADE: 'Final Grade', SECTION: 'Section' },
        GRADE_SCORES: { GRADE: 'Grade', LABEL: 'Label', SCORE: 'Score', MAX: 'Max Points' },
        RUBRICS: { NAME: 'Rubric Name', TEACHER: 'Teacher', ITEMS: 'Items' }
      }
    };

    const MANUAL_TRANSCRIPT_SW_PATH = 'manual-transcript-sw.js';

    const registerManualTranscriptServiceWorker = () => {
      if (typeof window === 'undefined') return;
      if (!('serviceWorker' in navigator)) {
        console.warn('[Manual Transcript] Service workers are not supported in this browser.');
        return;
      }
      if (window.location.protocol === 'file:') {
        console.warn('[Manual Transcript] Service worker disabled while served over file://');
        return;
      }
      navigator.serviceWorker.register(MANUAL_TRANSCRIPT_SW_PATH)
        .then((registration) => {
          console.log('[Manual Transcript] Service worker registered', registration.scope);
        })
        .catch((err) => {
          console.error('[Manual Transcript] Failed to register service worker', err);
        });
    };

    if (typeof window !== 'undefined') {
      registerManualTranscriptServiceWorker();
    }

    const Icon = ({ name, className = "w-5 h-5" }) => {
      const ref = React.useRef(null);

      React.useEffect(() => {
        if (window.lucide) window.lucide.createIcons();
      }, [name]);

      // Convert PascalCase to kebab-case for data-lucide
      const iconName = name.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
      return <i data-lucide={iconName} className={className} ref={ref} />;
    };

    const blobToBase64 = (blob) =>
      new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          const res = reader.result || '';
          const base64 = String(res).includes(',') ? String(res).split(',')[1] : String(res);
          resolve(base64);
        };
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });

    function chunk(arr, size = 10) {
      const out = [];
      for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
      return out;
    }

    function GradingInterface() {
      const [step, setStep] = useState('teacher-select');
      const [isRecording, setIsRecording] = useState(false);
      const [isPaused, setIsPaused] = useState(false);
      const [recordingTime, setRecordingTime] = useState(0);

      const [teachers, setTeachers] = useState([]);
      const [teacherQuery, setTeacherQuery] = useState('');
      const [selectedTeacher, setSelectedTeacher] = useState(null);

      const [sections, setSections] = useState([]);
      const [sectionQuery, setSectionQuery] = useState('');
      const [selectedSections, setSelectedSections] = useState([]);

      const [students, setStudents] = useState([]);
      const [studentOrder, setStudentOrder] = useState([]);
      const [assignmentName, setAssignmentName] = useState('');
      const [savedRubrics, setSavedRubrics] = useState([]);
      const [allRubrics, setAllRubrics] = useState([]);
      const [showRubricBrowser, setShowRubricBrowser] = useState(false);
      const [rubricFilterTeacher, setRubricFilterTeacher] = useState(null);
      const [rubricSearchQuery, setRubricSearchQuery] = useState('');
      const [rubricItems, setRubricItems] = useState([
        { name: 'Correctness', maxPoints: 25 },
        { name: 'Method', maxPoints: 25 },
        { name: 'Clarity', maxPoints: 25 },
        { name: 'Completeness', maxPoints: 25 }
      ]);
      const [grades, setGrades] = useState({});
      const [currentStudent, setCurrentStudent] = useState(null);

      const [transcript, setTranscript] = useState([]);
      const [showManualTranscriptInput, setShowManualTranscriptInput] = useState(false);
      const [manualTranscriptText, setManualTranscriptText] = useState('');
      const [manualTranscriptError, setManualTranscriptError] = useState(null);
      const [isSubmittingTranscript, setIsSubmittingTranscript] = useState(false);
      const manualTranscriptRequestsRef = useRef(new Map());
      const manualTranscriptInputRef = useRef(null);
      const [isManualTranscriptListenerReady, setIsManualTranscriptListenerReady] = useState(false);
      const manualTranscriptCallbackUrl = typeof window !== 'undefined'
        ? `${window.location.origin}${CONFIG.MANUAL_TRANSCRIPT_RESULT_PATH}`
        : '';
      const handleWebhookSuccessRef = useRef(null);
      const manualTranscriptListenerStatus = useMemo(() => {
        if (typeof window !== 'undefined' && window.location.protocol === 'file:') {
          return 'Unavailable on file:// (serve over HTTP/HTTPS)';
        }
        return isManualTranscriptListenerReady ? 'Active' : 'Not connected';
      }, [isManualTranscriptListenerReady]);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);
      const [selectedCell, setSelectedCell] = useState(null); // { row: idx, col: idx }
      const [selectedRow, setSelectedRow] = useState(null);
      const [selectedColumn, setSelectedColumn] = useState(null);
      const [editingStudent, setEditingStudent] = useState(null);
      const [editingField, setEditingField] = useState(null);
      const [sessionId, setSessionId] = useState(null);
      const [micError, setMicError] = useState(null);

      const [pendingCount, setPendingCount] = useState(0);
      const chunkIdRef = useRef(0);
      const isFlushingRef = useRef(false);

      const [isUploading, setIsUploading] = useState(false);
      const [uploadProgress, setUploadProgress] = useState({ current: 0, total: 0 });
      const [uploadComplete, setUploadComplete] = useState(false);

      const [sortField, setSortField] = useState('name');
      const [sortDirection, setSortDirection] = useState('asc');

      const [isDraftingEmail, setIsDraftingEmail] = useState(false);
      const [emailDraftSuccess, setEmailDraftSuccess] = useState(false);
      const [emailDraftError, setEmailDraftError] = useState(null);
      const [selectedEmailStudentIds, setSelectedEmailStudentIds] = useState([]);
      const tableRef = useRef(null);

      // PDF Grading State
      const [uploadedPDFs, setUploadedPDFs] = useState([]); // [{ file, filename, studentId, matchMethod }]
      const [showPDFMatchReview, setShowPDFMatchReview] = useState(false);
      const [pdfUploadError, setPdfUploadError] = useState(null);
      const [pdfPage, setPdfPage] = useState(1);
      const [pdfScale, setPdfScale] = useState(1.0);

      // Reset PDF viewer state when switching students
      useEffect(() => {
        setPdfPage(1);
        setPdfScale(1.0);
      }, [currentGradingStudentId]);

      // PDF Matching Utilities
      const parsePDFFilename = (filename) => {
        // Expected: LastNameFirstName_ID_Desc.pdf
        const cleanName = filename.replace(/\.pdf$/i, '');
        const parts = cleanName.split('_');

        let rawName = parts[0];
        let idPart = null;

        if (parts.length >= 2) {
          // Check if second part looks like an ID (digits)
          if (/^\d+$/.test(parts[1])) {
            idPart = parts[1];
          }
        }

        return { rawName, idPart };
      };

      const matchStudentToPDF = (file, studentsList) => {
        const { rawName, idPart } = parsePDFFilename(file.name);

        // 1. Try Exact ID Match (Primary)
        if (idPart) {
          const student = studentsList.find(s => String(s.studentId).includes(idPart) || String(idPart).includes(String(s.studentId)));
          if (student) return { student, method: 'ID Match', file };
        }

        // 2. Try Name Match (Secondary)
        // Normalize: remove spaces, lowercase
        const normFile = rawName.toLowerCase().replace(/[^a-z]/g, '');

        let bestMatch = null;
        let maxSimilarity = 0;

        studentsList.forEach(student => {
          const normStudent = student.name.toLowerCase().replace(/[^a-z]/g, '');
          // Simple containment check
          if (normFile.includes(normStudent) || normStudent.includes(normFile)) {
            // Prefer the one with closer length ratio
            const ratio = Math.min(normFile.length, normStudent.length) / Math.max(normFile.length, normStudent.length);
            if (ratio > maxSimilarity) {
              maxSimilarity = ratio;
              bestMatch = student;
            }
          }
        });

        if (bestMatch && maxSimilarity > 0.6) {
          return { student: bestMatch, method: 'Name Match', file };
        }

        return { student: null, method: 'Unmatched', file };
      };

      const handlePDFUpload = (e) => {
        const files = Array.from(e.target.files);
        if (files.length === 0) return;

        const results = files.filter(f => f.type === 'application/pdf').map(file => {
          return matchStudentToPDF(file, students);
        });

        setUploadedPDFs(prev => {
          // Merge new uploads, avoiding duplicates by filename
          const newMap = new Map(prev.map(p => [p.file.name, p]));
          results.forEach(r => newMap.set(r.file.name, r));
          return Array.from(newMap.values());
        });

        setShowPDFMatchReview(true);
      };

      // Copy selection to clipboard
      const copySelectionToClipboard = () => {
        if (selectedRow !== null) {
          // Copy entire row
          const student = sortedStudentsForResults[selectedRow];
          const sg = student.grade;
          const rowData = [
            student.name,
            ...rubricItems.map(item => sg.scores[item.name] ?? ''),
            student.total,
            sg.comments || ''
          ];
          navigator.clipboard.writeText(rowData.join('\t'));
        } else if (selectedColumn !== null) {
          // Copy entire column
          let columnData = [];
          if (selectedColumn === 0) {
            // Student names
            columnData = sortedStudentsForResults.map(s => s.name);
          } else if (selectedColumn <= rubricItems.length) {
            // Rubric item scores (columns 1 to rubricItems.length)
            const itemIdx = selectedColumn - 1;
            const itemName = rubricItems[itemIdx].name;
            columnData = sortedStudentsForResults.map(s => s.grade.scores[itemName] ?? '');
          } else if (selectedColumn === rubricItems.length + 1) {
            // Total column
            columnData = sortedStudentsForResults.map(s => s.total);
          } else if (selectedColumn === rubricItems.length + 2) {
            // Comments column
            columnData = sortedStudentsForResults.map(s => s.grade.comments || '');
          }
          navigator.clipboard.writeText(columnData.join('\n'));
          console.log('Column copied to clipboard');
        }
      };

      // Handle keyboard shortcuts
      useEffect(() => {
        const handleKeyDown = (e) => {
          if ((e.metaKey || e.ctrlKey) && e.key === 'c' && (selectedRow !== null || selectedColumn !== null)) {
            e.preventDefault();
            copySelectionToClipboard();
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [selectedRow, selectedColumn, sortedStudentsForResults, grades, rubricItems]);

      const mediaRecorderRef = useRef(null);
      const mediaStreamRef = useRef(null);
      const currentRecordingChunksRef = useRef([]);
      const completedRecordingsRef = useRef([]);
      const recordingStartTimeRef = useRef(null);
      const [recordingSegments, setRecordingSegments] = useState([]);

      // Rubric-click grading state
      const [gradingMode, setGradingMode] = useState('voice'); // 'voice' or 'rubric-click'
      const [currentGradingStudentId, setCurrentGradingStudentId] = useState(null);


      useEffect(() => {
        if (CONFIG.AIRTABLE_API_KEY === 'YOUR_AIRTABLE_API_KEY_HERE') {
          setError('Please configure your Airtable API key in the CONFIG section.');
        }
        loadTeachersFromAirtable();
      }, []);

      useEffect(() => {
        if (showManualTranscriptInput && manualTranscriptInputRef.current) {
          manualTranscriptInputRef.current.focus();
        }
      }, [showManualTranscriptInput]);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        if (!('serviceWorker' in navigator)) {
          setIsManualTranscriptListenerReady(false);
          return;
        }
        if (window.location.protocol === 'file:') {
          setIsManualTranscriptListenerReady(false);
          return;
        }

        let cancelled = false;

        const markReady = () => {
          if (!cancelled) setIsManualTranscriptListenerReady(true);
        };

        navigator.serviceWorker.getRegistration(MANUAL_TRANSCRIPT_SW_PATH)
          .then((registration) => {
            if (!cancelled && registration) {
              setIsManualTranscriptListenerReady(true);
            }
          })
          .catch(() => { });

        navigator.serviceWorker.ready
          .then(markReady)
          .catch(() => { });

        return () => {
          cancelled = true;
        };
      }, []);

      useEffect(() => {
        let interval;
        if (isRecording && !isPaused) {
          interval = setInterval(() => setRecordingTime(prev => prev + 1), 1000);
        }
        return () => clearInterval(interval);
      }, [isRecording, isPaused]);

      useEffect(() => {
        const handleKeyPress = (e) => {
          const tag = (e.target.tagName || '').toLowerCase();
          const isTyping = tag === 'input' || tag === 'textarea' || e.target.isContentEditable;
          if (isTyping) return;
          if (e.code === 'Space' && isRecording && !isPaused && !editingStudent) {
            e.preventDefault();
            sendChunkToWebhook();
          }
        };
        window.addEventListener('keydown', handleKeyPress);
        return () => window.removeEventListener('keydown', handleKeyPress);
      }, [isRecording, isPaused, editingStudent, rubricItems, students, grades, selectedTeacher, selectedSections, assignmentName, sessionId]);

      useEffect(() => {
        if (step === 'review') {
          const gradedIds = students
            .filter(student => grades[student.id]?.completed)
            .map(student => student.id);
          setSelectedEmailStudentIds(gradedIds);
        }
      }, [step]);

      const airtableRequest = async (endpoint, options = {}) => {
        const url = `https://api.airtable.com/v0/${CONFIG.AIRTABLE_BASE_ID}/${endpoint}`;
        const response = await fetch(url, {
          ...options,
          headers: {
            'Authorization': `Bearer ${CONFIG.AIRTABLE_API_KEY}`,
            'Content-Type': 'application/json',
            ...options.headers
          }
        });
        if (!response.ok) throw new Error(`Airtable API error: ${response.status} ${response.statusText}`);
        return response.json();
      };

      const loadTeachersFromAirtable = async () => {
        setLoading(true);
        setError(null);
        try {
          const data = await airtableRequest(CONFIG.TABLES.TEACHERS);
          const teachersList = (data.records || []).map(record => ({
            id: record.id,
            name: record.fields[CONFIG.FIELDS.TEACHERS.NAME]
              || `${record.fields[CONFIG.FIELDS.TEACHERS.FIRST_NAME] || ''} ${record.fields[CONFIG.FIELDS.TEACHERS.LAST_NAME] || ''}`.trim(),
            email: record.fields[CONFIG.FIELDS.TEACHERS.EMAIL]
          })).sort((a, b) => a.name.localeCompare(b.name));
          setTeachers(teachersList);
        } catch (err) {
          console.error('Error loading teachers:', err);
          setError('Failed to load teachers. Check configuration.');
        } finally {
          setLoading(false);
        }
      };

      const selectTeacher = async (teacher) => {
        setSelectedTeacher(teacher);
        setLoading(true);
        setStep('section-select');
        setError(null);
        try {
          const teacherData = await airtableRequest(`${CONFIG.TABLES.TEACHERS}/${teacher.id}`);
          const sectionIds = teacherData.fields[CONFIG.FIELDS.TEACHERS.SECTIONS] || [];
          if (sectionIds.length === 0) {
            setError(`No sections found for ${teacher.name}. Check if this teacher has sections linked in Airtable.`);
            setSections([]);
            setLoading(false);
            return;
          }
          const sectionsPromises = sectionIds.map(id => airtableRequest(`${CONFIG.TABLES.SECTIONS}/${id}`));
          const sectionsData = await Promise.all(sectionsPromises);
          const sectionsList = sectionsData.map(data => ({
            id: data.id,
            name: data.fields[CONFIG.FIELDS.SECTIONS.NAME] || 'Unnamed Section',
            sectionId: data.fields[CONFIG.FIELDS.SECTIONS.SECTION_ID],
            studentCount: data.fields[CONFIG.FIELDS.SECTIONS.STUDENT_ROSTER]?.length || 0
          }))
            .sort((a, b) => a.name.localeCompare(b.name));
          setSections(sectionsList);
        } catch (err) {
          console.error('Error loading sections:', err);
          setError(`Failed to load sections: ${err.message}`);
        } finally {
          setLoading(false);
        }
      };

      const toggleSection = (section) => {
        setSelectedSections(prev => {
          const isSelected = prev.find(s => s.id === section.id);
          if (isSelected) {
            return prev.filter(s => s.id !== section.id);
          } else {
            return [...prev, section];
          }
        });
      };

      const proceedWithSections = async () => {
        if (selectedSections.length === 0) {
          alert('Please select at least one section.');
          return;
        }

        setLoading(true);
        setStep('assignment-setup');
        setError(null);

        try {
          const allStudents = [];
          const studentIdsSeen = new Set();

          for (const section of selectedSections) {
            const sectionData = await airtableRequest(`${CONFIG.TABLES.SECTIONS}/${section.id}`);
            const studentIds = sectionData.fields[CONFIG.FIELDS.SECTIONS.STUDENT_ROSTER] || [];

            for (const studentId of studentIds) {
              if (!studentIdsSeen.has(studentId)) {
                studentIdsSeen.add(studentId);
                const studentData = await airtableRequest(`${CONFIG.TABLES.STUDENTS}/${studentId}`);
                allStudents.push({
                  id: studentData.id,
                  name: studentData.fields[CONFIG.FIELDS.STUDENTS.NAME],
                  email: studentData.fields[CONFIG.FIELDS.STUDENTS.EMAIL],
                  studentId: studentData.fields[CONFIG.FIELDS.STUDENTS.ID]?.toString() || 'N/A',
                  sectionId: section.id,
                  sectionName: section.name
                });
              }
            }
          }

          setStudents(allStudents);
          setStudentOrder(allStudents.map(s => s.id));

          const initialGrades = {};
          allStudents.forEach(student => {
            initialGrades[student.id] = { scores: {}, comments: '', completed: false };
          });
          setGrades(initialGrades);

          await loadSavedRubrics();

        } catch (err) {
          console.error('Error loading students:', err);
          setError('Failed to load students.');
        } finally {
          setLoading(false);
        }
      };

      const startGradingSession = async (mode = 'voice') => {
        if (!assignmentName.trim()) {
          alert('Please enter an assignment name.');
          return;
        }
        setSessionId(Date.now().toString());
        setGradingMode(mode);

        if (mode === 'rubric-click') {
          // For rubric-click mode, set the first ungraded student as current
          const firstStudent = students.find(s => !grades[s.id]?.completed);
          if (firstStudent) {
            setCurrentGradingStudentId(firstStudent.id);
          }
          setStep('rubric-click-grading');
        } else {
          // Voice grading mode (existing behavior)
          setStep('grading');
        }
      };

      const loadSavedRubrics = async () => {
        try {
          const response = await airtableRequest(CONFIG.TABLES.RUBRICS);

          const allRubricsWithTeachers = await Promise.all(
            response.records.map(async (record) => {
              const teacherLinks = record.fields[CONFIG.FIELDS.RUBRICS.TEACHER] || [];
              const teacherNames = [];

              for (const teacherId of teacherLinks) {
                try {
                  const teacherData = await airtableRequest(`${CONFIG.TABLES.TEACHERS}/${teacherId}`);
                  teacherNames.push(teacherData.fields[CONFIG.FIELDS.TEACHERS.NAME]);
                } catch (err) {
                  console.error('Error loading teacher:', err);
                }
              }

              return {
                id: record.id,
                name: record.fields[CONFIG.FIELDS.RUBRICS.NAME],
                items: JSON.parse(record.fields[CONFIG.FIELDS.RUBRICS.ITEMS] || '[]'),
                teacherIds: teacherLinks,
                teacherNames: teacherNames
              };
            })
          );

          setAllRubrics(allRubricsWithTeachers);

          const teacherRubrics = allRubricsWithTeachers.filter(rubric =>
            rubric.teacherIds.includes(selectedTeacher.id)
          );
          setSavedRubrics(teacherRubrics);
        } catch (err) {
          console.error('Error loading rubrics:', err);
        }
      };

      const saveCurrentRubric = async (rubricName) => {
        if (!rubricName.trim()) {
          alert('Please enter a rubric name.');
          return;
        }

        try {
          const rubricData = {
            fields: {
              [CONFIG.FIELDS.RUBRICS.NAME]: rubricName,
              [CONFIG.FIELDS.RUBRICS.TEACHER]: [selectedTeacher.id],
              [CONFIG.FIELDS.RUBRICS.ITEMS]: JSON.stringify(rubricItems)
            }
          };

          await airtableRequest(CONFIG.TABLES.RUBRICS, {
            method: 'POST',
            body: JSON.stringify({ records: [rubricData] })
          });

          alert(`Rubric "${rubricName}" saved successfully!`);
          await loadSavedRubrics();
        } catch (err) {
          console.error('Error saving rubric:', err);
          alert(`Failed to save rubric: ${err.message}`);
        }
      };

      const loadRubric = (rubric) => {
        setRubricItems(rubric.items);
        setShowRubricBrowser(false);
      };

      const openRubricBrowser = () => {
        setShowRubricBrowser(true);
        setRubricFilterTeacher(selectedTeacher);
        setRubricSearchQuery('');
      };

      const deleteRubric = async (rubricId, rubricName) => {
        if (!confirm(`Are you sure you want to delete the rubric "${rubricName}"?`)) {
          return;
        }

        try {
          await airtableRequest(`${CONFIG.TABLES.RUBRICS}/${rubricId}`, {
            method: 'DELETE'
          });

          alert(`Rubric "${rubricName}" deleted successfully!`);
          await loadSavedRubrics();
        } catch (err) {
          console.error('Error deleting rubric:', err);
          alert(`Failed to delete rubric: ${err.message}`);
        }
      };

      const getFilteredRubrics = () => {
        let filtered = allRubrics;

        if (rubricFilterTeacher) {
          filtered = filtered.filter(rubric =>
            rubric.teacherIds.includes(rubricFilterTeacher.id)
          );
        }

        if (rubricSearchQuery.trim()) {
          const query = rubricSearchQuery.toLowerCase();
          filtered = filtered.filter(rubric =>
            rubric.name.toLowerCase().includes(query) ||
            rubric.teacherNames.some(name => name.toLowerCase().includes(query))
          );
        }

        return filtered;
      };

      const startRecording = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaStreamRef.current = stream;

          startNewRecordingSegment();

          setIsRecording(true);
          setIsPaused(false);
          setRecordingTime(0);
          setMicError(null);

          console.log('Recording started - speak and press SPACEBAR to finish this segment and start next');
        } catch (err) {
          console.error('Microphone error:', err);
          setMicError('Microphone access denied');
        }
      };

      const startNewRecordingSegment = () => {
        if (!mediaStreamRef.current) return;

        const recorder = new MediaRecorder(mediaStreamRef.current, { mimeType: 'audio/webm' });
        mediaRecorderRef.current = recorder;
        currentRecordingChunksRef.current = [];
        recordingStartTimeRef.current = Date.now();

        recorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) {
            currentRecordingChunksRef.current.push(e.data);
            console.log('Received chunk:', e.data.size, 'bytes. Total chunks:', currentRecordingChunksRef.current.length, 'Total size:', currentRecordingChunksRef.current.reduce((sum, chunk) => sum + chunk.size, 0), 'bytes');
          }
        };

        recorder.start(1000);
        console.log('New recording segment started with 1s timeslice');
      };

      const pauseRecording = () => {
        if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
          mediaRecorderRef.current.pause();
          setIsPaused(true);
        }
      };

      const resumeRecording = () => {
        if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'paused') {
          mediaRecorderRef.current.resume();
          setIsPaused(false);
        }
      };

      const finishRecording = async () => {
        if (!mediaRecorderRef.current) return;

        if (currentRecordingChunksRef.current.length > 0) {
          await sendChunkToWebhook();
        }

        if (mediaStreamRef.current) {
          mediaStreamRef.current.getTracks().forEach(track => track.stop());
          mediaStreamRef.current = null;
        }

        setIsRecording(false);
        setIsPaused(false);
        mediaRecorderRef.current = null;

        console.log(`Recording stopped. Total segments: ${completedRecordingsRef.current.length}`);
      };

      const downloadRecording = (recordingData) => {
        const url = URL.createObjectURL(recordingData.blob);
        const a = document.createElement('a');
        a.href = url;
        const studentName = recordingData.studentName || `segment-${recordingData.chunkNumber}`;
        a.download = `${assignmentName.replace(/\s+/g, '_')}_${studentName.replace(/\s+/g, '_')}_${recordingData.chunkNumber}.webm`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      };

      const downloadAllRecordings = async () => {
        if (completedRecordingsRef.current.length === 0) {
          alert('No recordings to download yet.');
          return;
        }

        try {
          const zip = new JSZip();
          const folder = zip.folder(assignmentName.replace(/\s+/g, '_'));

          completedRecordingsRef.current.forEach((recording) => {
            const studentName = recording.studentName || `segment-${recording.chunkNumber}`;
            const filename = `${studentName.replace(/\s+/g, '_')}_${recording.chunkNumber}.webm`;
            folder.file(filename, recording.blob);
          });

          const zipBlob = await zip.generateAsync({ type: 'blob' });

          const url = URL.createObjectURL(zipBlob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `${assignmentName.replace(/\s+/g, '_')}_all_recordings_${sessionId}.zip`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          console.log(`Downloaded ${completedRecordingsRef.current.length} recordings as zip file`);
        } catch (err) {
          console.error('Error creating zip:', err);
          alert('Failed to create zip file. Try downloading individual recordings instead.');
        }
      };

      const downloadTranscript = () => {
        if (transcript.length === 0) {
          alert('No transcript to download yet.');
          return;
        }

        let transcriptText = `${assignmentName} - Grading Transcript\n`;
        transcriptText += `Teacher: ${selectedTeacher?.name}\n`;
        transcriptText += `Sections: ${selectedSections.map(s => s.name).join(', ')}\n`;
        transcriptText += `Date: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}\n`;
        transcriptText += `\n${'='.repeat(60)}\n\n`;

        [...transcript].reverse().forEach((entry, idx) => {
          if (!entry.isProcessing) {
            transcriptText += `${entry.timestamp || ''}\n${entry.text}\n\n`;
          }
        });

        const blob = new Blob([transcriptText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${assignmentName.replace(/\s+/g, '_')}_transcript_${sessionId}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        console.log('Downloaded transcript');
      };

      const handleEmailRecipientToggle = (studentId) => {
        if (!grades[studentId]?.completed) return;
        setSelectedEmailStudentIds(prev => (
          prev.includes(studentId)
            ? prev.filter(id => id !== studentId)
            : [...prev, studentId]
        ));
      };

      const selectAllEmailRecipients = () => {
        const gradedIds = students
          .filter(student => grades[student.id]?.completed)
          .map(student => student.id);
        setSelectedEmailStudentIds(gradedIds);
      };

      const clearEmailRecipients = () => {
        setSelectedEmailStudentIds([]);
      };

      const handleDraftEmail = async () => {
        if (!CONFIG.N8N_EMAIL_WEBHOOK_URL || CONFIG.N8N_EMAIL_WEBHOOK_URL.includes('YOUR_N8N_EMAIL_WEBHOOK_URL_HERE')) {
          alert('Please configure your n8n email webhook URL in the CONFIG section.');
          return;
        }

        setIsDraftingEmail(true);
        setEmailDraftError(null);
        setEmailDraftSuccess(false);

        if (selectedEmailStudentIds.length === 0) {
          setEmailDraftError('Select at least one graded student to draft emails.');
          setIsDraftingEmail(false);
          return;
        }

        try {
          // Build student rows
          const studentData = students.map(student => {
            const g = grades[student.id] || { scores: {}, comments: '', completed: false };
            const total = g.completed
              ? rubricItems.reduce((sum, item) => sum + (g.scores[item.name] || 0), 0)
              : null;

            const rubricScores = rubricItems.map(item => ({
              label: item.name,
              score: g?.scores?.[item.name] ?? null,
              maxPoints: item.maxPoints
            }));

            return {
              recordId: student.id,
              name: student.name,
              email: student.email || '',
              studentId: student.studentId,
              completed: !!g.completed,
              status: g?.completed ? 'Graded' : 'Not Graded',
              scores: g.scores || {},
              rubricScores,
              comments: g.comments || '',
              total
            };
          });

          const gradedOnly = studentData.filter(s => s.completed && s.total !== null);
          const selectedStudents = studentData.filter(s => selectedEmailStudentIds.includes(s.recordId));

          if (selectedStudents.length === 0) {
            setEmailDraftError('Select at least one graded student to draft emails.');
            setIsDraftingEmail(false);
            return;
          }

          const averageScore = selectedStudents.length
            ? Math.round(selectedStudents.reduce((acc, s) => acc + s.total, 0) / selectedStudents.length)
            : null;

          const payload = {
            teacher: { name: selectedTeacher?.name, email: selectedTeacher?.email },
            assignmentName,
            sections: selectedSections.map(s => ({ id: s.sectionId, name: s.name })),
            sectionNames: selectedSections.map(s => s.name),
            assignment: {
              name: assignmentName,
              rubric: rubricItems.map(item => ({ name: item.name, maxPoints: item.maxPoints })),
              maxTotal: rubricItems.reduce((sum, item) => sum + item.maxPoints, 0)
            },
            rubricTotals: {
              titles: rubricItems.map(i => i.name),
              maxPoints: rubricItems.map(i => i.maxPoints),
              overallMax: rubricItems.reduce((sum, i) => sum + i.maxPoints, 0)
            },
            students: selectedStudents,
            allStudents: studentData,
            summary: {
              totalStudents: students.length,
              gradedStudents: students.filter(s => grades[s.id]?.completed).length,
              selectedStudents: selectedStudents.length,
              averageScore
            },
            timestamp: new Date().toISOString()
          };

          const response = await fetch(CONFIG.N8N_EMAIL_WEBHOOK_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            const text = await response.text().catch(() => '');
            throw new Error(`Failed to send data to n8n (${response.status}): ${text || response.statusText}`);
          }

          try { console.log('Email draft response:', await response.json()); } catch { }
          setEmailDraftSuccess(true);
          setTimeout(() => setEmailDraftSuccess(false), 5000);
        } catch (err) {
          console.error('Error drafting email:', err);
          setEmailDraftError(err.message || 'Unknown error');
        } finally {
          setIsDraftingEmail(false);
        }
      };

      const sendChunkToWebhook = async () => {
        if (!mediaRecorderRef.current || mediaRecorderRef.current.state !== 'recording') {
          console.log('No active recording');
          setTranscript(prev => [...prev, {
            id: Date.now(),
            text: '⚠️ Recording not active. Please start recording first.',
            isProcessing: false
          }]);
          return;
        }

        const chunkNum = ++chunkIdRef.current;
        const segmentId = Date.now();
        const recordingDuration = Date.now() - recordingStartTimeRef.current;

        console.log(`[Segment ${chunkNum}] Stopping current recording (duration: ${(recordingDuration / 1000).toFixed(1)}s)...`);

        const currentRecorder = mediaRecorderRef.current;

        await new Promise((resolve) => {
          currentRecorder.onstop = () => {
            console.log(`[Segment ${chunkNum}] Recorder stopped. Collected ${currentRecordingChunksRef.current.length} chunks`);
            resolve();
          };
          currentRecorder.stop();
        });

        await new Promise(resolve => setTimeout(resolve, 100));

        const chunksToSend = [...currentRecordingChunksRef.current];

        if (chunksToSend.length === 0) {
          console.log(`[Segment ${chunkNum}] No audio chunks collected!`);
          setTranscript(prev => [...prev, {
            id: Date.now(),
            text: '⚠️ No audio recorded. Speak for a few seconds before pressing spacebar.',
            isProcessing: false
          }]);

          if (isRecording && !isPaused) {
            startNewRecordingSegment();
          }
          return;
        }

        const blob = new Blob(chunksToSend, { type: 'audio/webm' });

        console.log(`[Segment ${chunkNum}] Created blob from ${chunksToSend.length} chunks, total size: ${blob.size} bytes (${Math.round(blob.size / 1024)}KB)`);

        if (blob.size < 5000) {
          console.log(`[Segment ${chunkNum}] Recording too small (${blob.size} bytes), skipping...`);
          setTranscript(prev => [...prev, {
            id: Date.now(),
            text: `⚠️ Recording too short (${(recordingDuration / 1000).toFixed(1)}s). Speak longer before pressing spacebar.`,
            isProcessing: false
          }]);

          if (isRecording && !isPaused) {
            startNewRecordingSegment();
          }
          return;
        }

        const recordingData = {
          id: segmentId,
          blob: blob,
          chunkNumber: chunkNum,
          timestamp: new Date().toLocaleTimeString(),
          duration: recordingDuration,
          size: blob.size,
          studentName: null
        };

        completedRecordingsRef.current.push(recordingData);

        setRecordingSegments(prev => [...prev, {
          id: segmentId,
          chunkNumber: chunkNum,
          timestamp: recordingData.timestamp,
          duration: recordingDuration,
          size: blob.size,
          studentName: null,
          status: 'processing'
        }]);

        const entryId = Date.now();
        setTranscript(prev => [
          {
            id: entryId,
            text: `⏳ Processing segment ${chunkNum}... (${Math.round(blob.size / 1024)}KB, ${(recordingDuration / 1000).toFixed(1)}s)`,
            isProcessing: true,
            segmentNumber: chunkNum,
            timestamp: new Date().toLocaleTimeString()
          },
          ...prev
        ]);
        setPendingCount(prev => prev + 1);

        if (isRecording && !isPaused) {
          startNewRecordingSegment();
        }

        processSegmentWithN8N(segmentId, chunkNum, blob, entryId, recordingDuration);
      };

      const handleWebhookSuccess = ({
        result,
        entryId,
        chunkNum = null,
        recordingDuration = 0,
        segmentId = null,
        sourceLabel,
        appendTranscript = false,
        entryProcessingState = 'complete'
      }) => {
        const label = sourceLabel || (chunkNum !== null ? `Segment ${chunkNum}` : 'Manual Transcript');
        const durationSeconds = recordingDuration ? (recordingDuration / 1000).toFixed(1) : null;
        const headerLabel = durationSeconds ? `${label} (${durationSeconds}s)` : label;
        const logPrefix = chunkNum !== null ? `[Segment ${chunkNum}]` : `[${label}]`;

        const studentsData = normalizeWebhookResult(result, logPrefix);

        if (studentsData.length > 0) {
          let transcriptLines = [];
          let matchedStudents = [];
          let gradeUpdates = {};
          let studentIdsToMove = [];

          studentsData.forEach((studentResult, idx) => {
            console.log(`${logPrefix} Processing student ${idx + 1}/${studentsData.length}:`, studentResult.studentName, 'ID:', studentResult.studentId);

            if (studentResult.studentName && studentResult.scores) {
              let student = null;

              if (studentResult.studentId) {
                student = students.find(s => String(s.studentId) === String(studentResult.studentId)) ||
                  students.find(s => s.id === studentResult.studentId);
                if (student) {
                  console.log(`${logPrefix}   ✓ Matched by ID: ${student.name}`);
                } else {
                  console.log(`${logPrefix}   ✗ No match by ID ${studentResult.studentId}`);
                  console.log(`${logPrefix}   Available IDs:`, students.slice(0, 5).map(s => `${s.name}: ${s.studentId}`));
                }
              }

              if (!student && studentResult.studentName) {
                const target = String(studentResult.studentName).trim().toLowerCase();
                student = students.find(s => (s.name || '').trim().toLowerCase() === target);
                if (student) {
                  console.log(`${logPrefix}   ✓ Matched by name: ${student.name}`);
                } else {
                  console.log(`${logPrefix}   ✗ No match by name "${studentResult.studentName}"`);
                }
              }

              if (student) {
                const line = `${student.name}. ${Object.entries(studentResult.scores).map(([k, v]) => `${k} ${v}`).join(', ')}${studentResult.comments ? `. ${studentResult.comments}` : ''}`;
                transcriptLines.push(line);
                matchedStudents.push(student.name);
                studentIdsToMove.push(student.id);

                gradeUpdates[student.id] = {
                  scores: studentResult.scores,
                  comments: studentResult.comments || '',
                  completed: true
                };

                console.log(`${logPrefix} ✅ Prepared grade for ${student.name}`, studentResult.scores);
              } else {
                transcriptLines.push(`${studentResult.studentName} (no match in roster)`);
                console.log(`${logPrefix} ❌ Student not in roster: ${studentResult.studentName}`);
              }
            }
          });

          if (Object.keys(gradeUpdates).length > 0) {
            console.log(`${logPrefix} ===== APPLYING ${Object.keys(gradeUpdates).length} GRADE UPDATES =====`);
            console.log(`${logPrefix} Students to update:`, matchedStudents);
            console.log(`${logPrefix} Grade data:`, gradeUpdates);

            setGrades(prev => {
              const updated = { ...prev };
              Object.entries(gradeUpdates).forEach(([studentId, gradeData]) => {
                const studentName = students.find(s => s.id === studentId)?.name;
                console.log(`${logPrefix}   Setting grade for ${studentName} (${studentId}):`, gradeData);
                updated[studentId] = {
                  scores: { ...(prev[studentId]?.scores || {}), ...gradeData.scores },
                  comments: gradeData.comments || prev[studentId]?.comments || '',
                  completed: true
                };
              });
              console.log(`${logPrefix} Updated grades state:`, Object.keys(updated).length, 'students');
              return updated;
            });

            if (studentIdsToMove.length > 0) {
              setStudentOrder(prev => {
                const remaining = prev.filter(id => !studentIdsToMove.includes(id));
                return [...studentIdsToMove, ...remaining];
              });
              console.log(`${logPrefix} Moved ${studentIdsToMove.length} student(s) to top of list`);
            }

            if (matchedStudents.length > 0) {
              setCurrentStudent(matchedStudents[matchedStudents.length - 1]);
            }
          }

          if (transcriptLines.length > 0) {
            const formattedText = `📍 ${headerLabel}\n${transcriptLines.map(line => `  • ${line}`).join('\n')}`;

            setTranscript(prev => {
              const filtered = prev.filter(e => e.id !== entryId);
              const existing = prev.find(e => e.id === entryId);
              const combinedText = appendTranscript && existing
                ? `${existing.text}\n${formattedText}`
                : formattedText;
              return [
                {
                  id: entryId,
                  text: combinedText,
                  isProcessing: entryProcessingState !== 'complete',
                  segmentNumber: chunkNum,
                  timestamp: new Date().toLocaleTimeString()
                },
                ...filtered
              ];
            });

            if (segmentId) {
              setRecordingSegments(prev => prev.map(seg =>
                seg.id === segmentId ? {
                  ...seg,
                  studentName: matchedStudents.length > 0 ? matchedStudents.join(', ') : studentsData.map(s => s.studentName).join(', '),
                  status: 'completed'
                } : seg
              ));

              const recordingIndex = completedRecordingsRef.current.findIndex(r => r.id === segmentId);
              if (recordingIndex !== -1) {
                completedRecordingsRef.current[recordingIndex].studentName = matchedStudents.join(', ');
              }
            }

            console.log(`${logPrefix} ===== SUMMARY: ${matchedStudents.length}/${studentsData.length} students matched and graded =====`);
          } else {
            setTranscript(prev => {
              const filtered = prev.filter(e => e.id !== entryId);
              const existing = prev.find(e => e.id === entryId);
              const baseText = `📍 ${label} - No students matched`;
              const combinedText = appendTranscript && existing
                ? `${existing.text}\n${baseText}`
                : baseText;
              return [
                {
                  id: entryId,
                  text: combinedText,
                  isProcessing: entryProcessingState !== 'complete',
                  segmentNumber: chunkNum,
                  timestamp: new Date().toLocaleTimeString()
                },
                ...filtered
              ];
            });

            if (segmentId) {
              setRecordingSegments(prev => prev.map(seg =>
                seg.id === segmentId ? { ...seg, status: 'no-match' } : seg
              ));
            }
          }
        } else {
          setTranscript(prev => {
            const filtered = prev.filter(e => e.id !== entryId);
            const existing = prev.find(e => e.id === entryId);
            const baseText = `📍 ${label} - Processed without grade data`;
            const combinedText = appendTranscript && existing
              ? `${existing.text}\n${baseText}`
              : baseText;
            return [
              {
                id: entryId,
                text: combinedText,
                isProcessing: entryProcessingState !== 'complete',
                segmentNumber: chunkNum,
                timestamp: new Date().toLocaleTimeString()
              },
              ...filtered
            ];
          });

          if (segmentId) {
            setRecordingSegments(prev => prev.map(seg =>
              seg.id === segmentId ? { ...seg, status: 'completed' } : seg
            ));
          }

          console.log(`${logPrefix} Processed without grade data`);
        }
      };

      useEffect(() => {
        handleWebhookSuccessRef.current = handleWebhookSuccess;
      });

      const processManualTranscriptResult = useCallback((payload) => {
        if (!payload) return;

        const requestsMap = manualTranscriptRequestsRef.current;
        const explicitId = payload.requestId || payload.transcriptRequestId || payload.manualTranscriptRequestId;
        const interpretFinalFlag = (value) => {
          if (value === undefined || value === null) return false;
          if (typeof value === 'string') {
            return value.toLowerCase() === 'true';
          }
          return Boolean(value);
        };

        let targetRequestId = null;
        if (explicitId && requestsMap.has(explicitId)) {
          targetRequestId = explicitId;
        } else if (!explicitId && requestsMap.size === 1) {
          targetRequestId = Array.from(requestsMap.keys())[0];
        } else if (explicitId && !requestsMap.has(explicitId)) {
          console.warn('[Manual Transcript] Received result for unknown requestId', explicitId);
          return;
        } else if (!explicitId) {
          console.warn('[Manual Transcript] Result received without requestId and multiple requests pending.');
          return;
        }

        const requestId = targetRequestId;
        let requestState = requestsMap.get(requestId);
        if (!requestState) {
          console.warn('[Manual Transcript] Missing request state for', requestId);
          return;
        }

        const rawResult = payload.result !== undefined ? payload.result : payload;
        const logPrefix = `[Manual Transcript Async ${requestId}]`;
        const newStudents = normalizeWebhookResult(rawResult, logPrefix);

        if (!Array.isArray(newStudents) || newStudents.length === 0) {
          const isFinal = interpretFinalFlag(payload?.isFinal ?? payload?.final ?? payload?.done ?? payload?.complete ?? payload?.finished ?? payload?.finalized);
          if (isFinal) {
            handleWebhookSuccessRef.current?.({
              result: [],
              entryId: requestState.entryId,
              sourceLabel: payload?.sourceLabel || 'Manual Transcript',
              appendTranscript: false,
              entryProcessingState: 'complete'
            });
            requestsMap.delete(requestId);
            setPendingCount(prev => Math.max(0, prev - 1));
          }
          return;
        }

        const aggregated = Array.isArray(requestState.students) ? [...requestState.students] : [];

        newStudents.forEach((student) => {
          if (!student) return;
          const matchIndex = aggregated.findIndex(existing => {
            if (existing.studentId && student.studentId) {
              return String(existing.studentId) === String(student.studentId);
            }
            if (existing.studentName && student.studentName) {
              return existing.studentName.trim().toLowerCase() === String(student.studentName).trim().toLowerCase();
            }
            return false;
          });
          if (matchIndex >= 0) {
            aggregated[matchIndex] = { ...aggregated[matchIndex], ...student };
          } else {
            aggregated.push(student);
          }
        });

        requestState = { ...requestState, students: aggregated };
        requestsMap.set(requestId, requestState);

        const isFinal = interpretFinalFlag(payload?.isFinal ?? payload?.final ?? payload?.done ?? payload?.complete ?? payload?.finished ?? payload?.finalized);

        handleWebhookSuccessRef.current?.({
          result: aggregated,
          entryId: requestState.entryId,
          sourceLabel: payload?.sourceLabel || 'Manual Transcript',
          appendTranscript: false,
          entryProcessingState: isFinal ? 'complete' : 'pending'
        });

        if (isFinal) {
          requestsMap.delete(requestId);
          setPendingCount(prev => Math.max(0, prev - 1));
        }
      }, [setPendingCount]);

      useEffect(() => {
        if (typeof window === 'undefined') return;
        if (!('serviceWorker' in navigator)) return;

        const handler = (event) => {
          const data = event?.data;
          if (!data || data.type !== 'manual-transcript-result') return;
          processManualTranscriptResult(data.payload);
        };

        navigator.serviceWorker.addEventListener('message', handler);

        return () => {
          navigator.serviceWorker.removeEventListener('message', handler);
        };
      }, [processManualTranscriptResult]);

      const processSegmentWithN8N = async (segmentId, chunkNum, blob, entryId, recordingDuration) => {
        try {
          const base64 = await blobToBase64(blob);
          const filename = `segment-${sessionId}-${chunkNum}.webm`;

          const roster = students.map(s => ({
            id: s.id,
            studentId: s.studentId,
            name: s.name,
            email: s.email
          }));

          const payload = {
            audio: {
              filename,
              mimeType: 'audio/webm',
              encoding: 'base64',
              data: base64
            },
            session: {
              id: sessionId || '',
              chunkNumber: chunkNum,
              assignment: assignmentName || '',
              teacherName: selectedTeacher?.name || '',
              teacherEmail: selectedTeacher?.email || '',
              teacherId: selectedTeacher?.id || '',
              sections: selectedSections.map(s => ({ name: s.name, id: s.id }))
            },
            rubric: rubricItems,
            roster
          };

          const logPrefix = `[Segment ${chunkNum}]`;
          console.log(`${logPrefix} Sending to n8n...`);

          const response = await fetchWithTimeout(CONFIG.N8N_WEBHOOK_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          }, WEBHOOK_TIMEOUT_MS);

          console.log(`${logPrefix} Response status: ${response.status}`);

          if (!response.ok) {
            const errorText = await response.text().catch(() => 'Unknown error');
            console.error(`${logPrefix} Error response:`, errorText);
            throw new Error(`n8n webhook error (${response.status}): ${errorText}`);
          }

          const result = await response.json();
          console.log(`${logPrefix} Result:`, result);

          handleWebhookSuccess({
            result,
            entryId,
            chunkNum,
            recordingDuration,
            segmentId,
            sourceLabel: `Segment ${chunkNum}`
          });

        } catch (err) {
          const logPrefix = `[Segment ${chunkNum}]`;
          console.error(`${logPrefix} Processing error:`, err);
          const message = err && err.message ? err.message : 'Unknown error';
          const isTimeout = err && err.name === 'AbortError';
          const errorMessage = isTimeout
            ? `n8n request timed out after ${WEBHOOK_TIMEOUT_MINUTES} minutes on segment ${chunkNum}.`
            : message.includes('n8n')
              ? `n8n error on segment ${chunkNum}: ${message}`
              : `Processing error: ${message}`;
          setTranscript(prev => {
            const filtered = prev.filter(e => e.id !== entryId);
            return [
              {
                id: entryId,
                text: `❌ ${errorMessage}`,
                isProcessing: false,
                segmentNumber: chunkNum,
                timestamp: new Date().toLocaleTimeString()
              },
              ...filtered
            ];
          });
          if (segmentId) {
            setRecordingSegments(prev => prev.map(seg =>
              seg.id === segmentId ? { ...seg, status: 'error' } : seg
            ));
          }
        } finally {
          setPendingCount(prev => Math.max(0, prev - 1));
          console.log(`[Segment ${chunkNum}] Processing complete`);
        }
      };

      const submitManualTranscript = async () => {
        if (!CONFIG.N8N_TRANSCRIPT_WEBHOOK_URL) {
          setManualTranscriptError('Transcript webhook URL is not configured.');
          return;
        }

        if (typeof window !== 'undefined') {
          if (window.location.protocol === 'file:') {
            setManualTranscriptError('Serve the app over http:// or https:// to submit transcripts.');
            return;
          }
          if (!('serviceWorker' in navigator)) {
            setManualTranscriptError('This browser does not support the transcript callback listener.');
            return;
          }
        }

        if (!isManualTranscriptListenerReady) {
          setManualTranscriptError('Transcript listener is still starting up. Please try again in a moment.');
          return;
        }

        if (!manualTranscriptText.trim()) {
          setManualTranscriptError('Please paste a transcript before submitting.');
          return;
        }

        const logPrefix = '[Manual Transcript]';
        const entryId = Date.now();
        const timestamp = new Date().toLocaleTimeString();
        const requestId = (typeof crypto !== 'undefined' && crypto.randomUUID)
          ? crypto.randomUUID()
          : `manual-${Date.now()}-${Math.random().toString(16).slice(2)}`;

        setManualTranscriptError(null);
        setIsSubmittingTranscript(true);
        setPendingCount(prev => prev + 1);
        setTranscript(prev => [
          {
            id: entryId,
            text: '⏳ Processing manual transcript...',
            isProcessing: true,
            segmentNumber: null,
            timestamp
          },
          ...prev
        ]);

        manualTranscriptRequestsRef.current.set(requestId, { entryId, students: [] });

        try {
          const roster = students.map(s => ({
            id: s.id,
            studentId: s.studentId,
            name: s.name,
            email: s.email
          }));

          const callbackUrl = manualTranscriptCallbackUrl || (typeof window !== 'undefined'
            ? `${window.location.origin}${CONFIG.MANUAL_TRANSCRIPT_RESULT_PATH}`
            : '');

          const payload = {
            transcript: {
              text: manualTranscriptText.trim(),
              requestId
            },
            callbackUrl,
            session: {
              id: sessionId || '',
              assignment: assignmentName || '',
              teacherName: selectedTeacher?.name || '',
              teacherEmail: selectedTeacher?.email || '',
              teacherId: selectedTeacher?.id || '',
              sections: selectedSections.map(s => ({ name: s.name, id: s.id }))
            },
            rubric: rubricItems,
            roster
          };

          console.log(`${logPrefix} Sending to n8n...`);

          const response = await fetchWithTimeout(CONFIG.N8N_TRANSCRIPT_WEBHOOK_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          }, WEBHOOK_TIMEOUT_MS);

          console.log(`${logPrefix} Response status: ${response.status}`);

          if (!response.ok) {
            const errorText = await response.text().catch(() => 'Unknown error');
            console.error(`${logPrefix} Error response:`, errorText);
            throw new Error(`n8n webhook error (${response.status}): ${errorText}`);
          }

          console.log(`${logPrefix} Upload acknowledged by n8n. Awaiting async results...`);

          setTranscript(prev => prev.map(entry =>
            entry.id === entryId
              ? {
                ...entry,
                text: '📨 Transcript received. Awaiting analysis…',
                isProcessing: true,
                timestamp: new Date().toLocaleTimeString()
              }
              : entry
          ));

          setManualTranscriptText('');
          setShowManualTranscriptInput(false);
          console.log(`${logPrefix} Callback URL for results: ${callbackUrl} (requestId: ${requestId})`);
        } catch (err) {
          console.error(`${logPrefix} Processing error:`, err);
          manualTranscriptRequestsRef.current.delete(requestId);
          const message = err && err.message ? err.message : 'Unknown error';
          const isTimeout = err && err.name === 'AbortError';
          const errorMessage = isTimeout
            ? `Manual transcript request timed out after ${WEBHOOK_TIMEOUT_MINUTES} minutes.`
            : message.includes('n8n')
              ? `n8n error on manual transcript: ${message}`
              : `Processing error: ${message}`;

          setTranscript(prev => {
            const filtered = prev.filter(e => e.id !== entryId);
            return [
              {
                id: entryId,
                text: `❌ ${errorMessage}`,
                isProcessing: false,
                segmentNumber: null,
                timestamp: new Date().toLocaleTimeString()
              },
              ...filtered
            ];
          });

          setManualTranscriptError(errorMessage);
        } finally {
          setIsSubmittingTranscript(false);
          const requestsMap = manualTranscriptRequestsRef.current;
          const stillPending = requestsMap.has(requestId);
          if (!stillPending) {
            setPendingCount(prev => Math.max(0, prev - 1));
          }
          console.log(`${logPrefix} Submission complete${manualTranscriptRequestsRef.current.has(requestId) ? ' - awaiting async grades' : ''}`);
        }
      };

      // Spreadsheet table handlers
      const handleCellClick = (rowIdx, colIdx) => {
        setSelectedCell({ row: rowIdx, col: colIdx });
        setSelectedColumn(null);
      };

      const handleColumnHeaderClick = (colIdx) => {
        setSelectedColumn(colIdx);
        setSelectedCell(null);
      };

      const handleTableKeyDown = (e) => {
        if (!selectedCell) return;

        const totalRows = students.length;
        const totalCols = rubricItems.length + 4; // name, status, rubric items, total, comments

        let newRow = selectedCell.row;
        let newCol = selectedCell.col;

        switch (e.key) {
          case 'ArrowUp':
            e.preventDefault();
            newRow = Math.max(0, selectedCell.row - 1);
            break;
          case 'ArrowDown':
            e.preventDefault();
            newRow = Math.min(totalRows - 1, selectedCell.row + 1);
            break;
          case 'ArrowLeft':
            e.preventDefault();
            newCol = Math.max(0, selectedCell.col - 1);
            break;
          case 'ArrowRight':
            e.preventDefault();
            newCol = Math.min(totalCols - 1, selectedCell.col + 1);
            break;
          case 'Tab':
            e.preventDefault();
            if (e.shiftKey) {
              newCol = selectedCell.col - 1;
              if (newCol < 0) {
                newCol = totalCols - 1;
                newRow = Math.max(0, selectedCell.row - 1);
              }
            } else {
              newCol = selectedCell.col + 1;
              if (newCol >= totalCols) {
                newCol = 0;
                newRow = Math.min(totalRows - 1, selectedCell.row + 1);
              }
            }
            break;
          case 'Enter':
            e.preventDefault();
            newRow = Math.min(totalRows - 1, selectedCell.row + 1);
            break;
          default:
            return;
        }

        setSelectedCell({ row: newRow, col: newCol });

        // Focus the cell after state update
        setTimeout(() => {
          const cell = document.querySelector(`[data-row="${newRow}"][data-col="${newCol}"]`);
          if (cell) {
            const input = cell.querySelector('input');
            if (input) {
              input.focus();
            } else {
              cell.focus();
            }
          }
        }, 0);
      };

      const copySelectedColumn = () => {
        if (selectedColumn === null) return;

        let data = [];
        const colIdx = selectedColumn;

        // Determine which column is selected
        if (colIdx === 0) {
          // Name column
          data = students.map(s => s.name);
        } else if (colIdx === 1) {
          // Status column
          data = students.map(s => grades[s.id]?.completed ? 'Graded' : 'Not Graded');
        } else if (colIdx >= 2 && colIdx < 2 + rubricItems.length) {
          // Rubric item column
          const itemIdx = colIdx - 2;
          const itemName = rubricItems[itemIdx].name;
          data = students.map(s => {
            const score = grades[s.id]?.scores[itemName];
            return score !== undefined ? score.toString() : '';
          });
        } else if (colIdx === 2 + rubricItems.length) {
          // Total column
          data = students.map(s => {
            const grade = grades[s.id];
            return grade?.completed ? calculateTotal(grade).toString() : '--';
          });
        } else if (colIdx === 3 + rubricItems.length) {
          // Comments column
          data = students.map(s => grades[s.id]?.comments || '');
        }

        const text = data.join('\n');
        navigator.clipboard.writeText(text).then(() => {
          console.log('Column copied to clipboard');
        }).catch(err => {
          console.error('Error copying to clipboard:', err);
        });
      };

      useEffect(() => {
        const handleGlobalKeyDown = (e) => {
          // Handle Ctrl+C / Cmd+C for copying column
          if ((e.ctrlKey || e.metaKey) && e.key === 'c' && selectedColumn !== null) {
            e.preventDefault();
            copySelectedColumn();
          }
        };

        window.addEventListener('keydown', handleGlobalKeyDown);
        return () => window.removeEventListener('keydown', handleGlobalKeyDown);
      }, [selectedColumn, students, grades, rubricItems]);

      const updateScore = (studentId, rubricName, value) => {
        setGrades(prev => {
          const existingGrade = prev[studentId] || { scores: {}, comments: '', completed: false };
          const updatedScores = { ...existingGrade.scores, [rubricName]: value };

          const allScoresFilled = rubricItems.every(item =>
            updatedScores[item.name] !== undefined &&
            updatedScores[item.name] !== null &&
            updatedScores[item.name] !== ''
          );

          if (allScoresFilled && !existingGrade.completed) {
            setTimeout(() => bumpStudentDown(studentId), 0);
          }

          return {
            ...prev,
            [studentId]: {
              ...existingGrade,
              scores: updatedScores,
              completed: allScoresFilled
            }
          };
        });
      };

      const updateComments = (studentId, value) => {
        setGrades(prev => {
          const existingGrade = prev[studentId] || { scores: {}, comments: '', completed: false };
          return {
            ...prev,
            [studentId]: {
              ...existingGrade,
              comments: value
            }
          };
        });
      };

      const calculateTotal = (studentGrade) => {
        return Object.values(studentGrade.scores).reduce((sum, score) => sum + (score || 0), 0);
      };

      const calculateMaxTotal = () => {
        return rubricItems.reduce((sum, item) => sum + item.maxPoints, 0);
      };

      const bumpStudentDown = (studentId) => {
        setStudentOrder(prev => {
          const idx = prev.indexOf(studentId);
          if (idx === -1) return prev;

          const next = prev.filter(id => id !== studentId);

          return [studentId, ...next];
        });
      };

      const getInitials = (name) => {
        return name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2);
      };

      // Helper functions for rubric-click grading
      const calculateRubricScoreOptions = (maxPoints) => {
        if (maxPoints <= 0) return [0];

        // For 5 points or less, show all individual values
        if (maxPoints <= 5) {
          const options = [];
          for (let i = 0; i <= maxPoints; i++) {
            options.push(i);
          }
          return options;
        }

        // For more than 5 points, show 6 evenly distributed options (including 0 and max)
        // This gives us 0%, 20%, 40%, 60%, 80%, 100%
        const options = [];
        for (let i = 0; i < 6; i++) {
          const value = Math.round((maxPoints * i) / 5);
          options.push(value);
        }

        // Remove duplicates (in case rounding created any)
        return [...new Set(options)];
      };

      const selectNextUngradedStudent = () => {
        const currentIndex = students.findIndex(s => s.id === currentGradingStudentId);
        // Find next ungraded student after current
        for (let i = currentIndex + 1; i < students.length; i++) {
          if (!grades[students[i].id]?.completed) {
            setCurrentGradingStudentId(students[i].id);
            return;
          }
        }
        // If no ungraded students after current, check from beginning
        for (let i = 0; i < currentIndex; i++) {
          if (!grades[students[i].id]?.completed) {
            setCurrentGradingStudentId(students[i].id);
            return;
          }
        }
        // No ungraded students found - stay on current or go to first
        if (!students.length) return;
        setCurrentGradingStudentId(students[0].id);
      };

      const updateRubricClickScore = (studentId, rubricItemName, score) => {
        setGrades(prev => ({
          ...prev,
          [studentId]: {
            ...prev[studentId],
            scores: {
              ...prev[studentId]?.scores,
              [rubricItemName]: score
            }
          }
        }));
      };

      const completeCurrentStudent = () => {
        if (!currentGradingStudentId) return;

        setGrades(prev => ({
          ...prev,
          [currentGradingStudentId]: {
            ...prev[currentGradingStudentId],
            completed: true
          }
        }));

        // Move completed student to top of order
        setStudentOrder(prev => {
          const remaining = prev.filter(id => id !== currentGradingStudentId);
          return [currentGradingStudentId, ...remaining];
        });

        selectNextUngradedStudent();
      };

      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      };

      const addRubricItem = () => {
        setRubricItems([...rubricItems, { name: `Criterion ${rubricItems.length + 1}`, maxPoints: 10 }]);
      };

      const updateRubricItem = (index, field, value) => {
        const updated = [...rubricItems];
        updated[index][field] = field === 'maxPoints' ? parseInt(value) || 0 : value;
        setRubricItems(updated);
      };

      const removeRubricItem = (index) => {
        if (rubricItems.length > 1) setRubricItems(rubricItems.filter((_, i) => i !== index));
      };

      const orderedStudents = useMemo(() => {
        return studentOrder.map(id => students.find(s => s.id === id)).filter(Boolean);
      }, [studentOrder, students]);

      const filteredTeachers = useMemo(() => {
        const q = teacherQuery.toLowerCase();
        return teachers.filter(t => t.name.toLowerCase().includes(q) || (t.email || '').toLowerCase().includes(q));
      }, [teachers, teacherQuery]);

      const filteredSections = useMemo(() => {
        const q = sectionQuery.toLowerCase();
        return sections.filter(s => s.name.toLowerCase().includes(q) || (s.sectionId || '').toLowerCase().includes(q));
      }, [sections, sectionQuery]);

      const toggleSort = (field) => {
        if (sortField === field) {
          setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
        } else {
          setSortField(field);
          setSortDirection('asc');
        }
      };

      const sortedStudentsForResults = useMemo(() => {
        const studentsWithGrades = students.map(student => {
          const grade = grades[student.id] || { scores: {}, comments: '', completed: false };
          return { ...student, grade, total: calculateTotal(grade) };
        });

        return studentsWithGrades.sort((a, b) => {
          let aVal, bVal;

          if (sortField === 'name') {
            aVal = a.name;
            bVal = b.name;
          } else if (sortField === 'total') {
            aVal = a.total;
            bVal = b.total;
          } else if (sortField === 'status') {
            aVal = a.grade.completed ? 1 : 0;
            bVal = b.grade.completed ? 1 : 0;
          } else {
            aVal = a.grade.scores[sortField] || 0;
            bVal = b.grade.scores[sortField] || 0;
          }

          if (typeof aVal === 'string') {
            return sortDirection === 'asc'
              ? aVal.localeCompare(bVal)
              : bVal.localeCompare(aVal);
          } else {
            return sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
          }
        });
      }, [students, grades, sortField, sortDirection, rubricItems]);

      const uploadGradesToAirtable = async () => {
        if (isUploading) return;

        const completedGrades = Object.entries(grades).filter(([_, g]) => g.completed);
        if (completedGrades.length === 0) {
          alert('No completed grades to upload. Please complete at least one student grade.');
          return;
        }

        setIsUploading(true);
        setUploadProgress({ current: 0, total: completedGrades.length });
        setError(null);

        let gradesSaved = false;

        try {
          const gradeRecordsToCreate = completedGrades.map(([studentId, gradeData]) => {
            const student = students.find(s => s.id === studentId);
            const total = calculateTotal(gradeData);

            return {
              fields: {
                [CONFIG.FIELDS.GRADES.ASSIGNMENT]: assignmentName,
                [CONFIG.FIELDS.GRADES.STUDENT]: [studentId],
                [CONFIG.FIELDS.GRADES.SECTION]: [student.sectionId],
                [CONFIG.FIELDS.GRADES.COMMENTS]: gradeData.comments || '',
                [CONFIG.FIELDS.GRADES.FINAL_GRADE]: total
              }
            };
          });

          const gradeChunks = chunk(gradeRecordsToCreate, 10);
          const createdPairs = [];

          for (let i = 0; i < gradeChunks.length; i++) {
            const start = i * 10;
            const thisChunkCompleted = completedGrades.slice(start, start + gradeChunks[i].length);

            const response = await airtableRequest(CONFIG.TABLES.GRADES, {
              method: 'POST',
              body: JSON.stringify({ records: gradeChunks[i] })
            });

            response.records.forEach((rec, j) => {
              const [studentId, gradeData] = thisChunkCompleted[j] || [];
              if (studentId && gradeData) {
                createdPairs.push({ gradeRecordId: rec.id, studentId, gradeData });
              }
            });

            setUploadProgress({
              current: Math.min((i + 1) * 10, completedGrades.length),
              total: completedGrades.length
            });
          }

          gradesSaved = true;
          console.log(`Successfully created ${createdPairs.length} grade records`);

          const scoreRecordsToCreate = [];
          createdPairs.forEach(({ gradeRecordId, gradeData }) => {
            rubricItems.forEach(item => {
              const score = gradeData.scores[item.name];
              if (score !== undefined && score !== null && score !== '') {
                scoreRecordsToCreate.push({
                  fields: {
                    [CONFIG.FIELDS.GRADE_SCORES.GRADE]: [gradeRecordId],
                    [CONFIG.FIELDS.GRADE_SCORES.LABEL]: item.name,
                    [CONFIG.FIELDS.GRADE_SCORES.SCORE]: score,
                    [CONFIG.FIELDS.GRADE_SCORES.MAX]: item.maxPoints
                  }
                });
              }
            });
          });

          if (scoreRecordsToCreate.length > 0) {
            try {
              const scoreChunks = chunk(scoreRecordsToCreate, 10);
              for (let i = 0; i < scoreChunks.length; i++) {
                await airtableRequest(CONFIG.TABLES.GRADE_SCORES, {
                  method: 'POST',
                  body: JSON.stringify({ records: scoreChunks[i] })
                });
              }
              console.log(`Successfully created ${scoreRecordsToCreate.length} score records`);
            } catch (scoreErr) {
              console.error('Error creating score records:', scoreErr);
              setError(`Grades saved, but some score details failed: ${scoreErr.message}`);
            }
          }

          setUploadComplete(true);
          console.log('Upload complete! Grades saved to Airtable.');

        } catch (err) {
          console.error('Upload error:', err);
          setError(`Failed to upload grades: ${err.message}`);
          alert(`Upload failed: ${err.message}`);
        } finally {
          setIsUploading(false);
        }
      };

      if (loading && step === 'teacher-select') {
        return (
          <div className="min-h-screen bg-white flex items-center justify-center">
            <div className="text-center">
              <div className="animate-spin rounded-full h-16 w-16 border-b-2 border-pacifica-navy mx-auto mb-4"></div>
              <p className="text-pacifica-slate">Loading teachers...</p>
            </div>
          </div>
        );
      }

      if (step === 'teacher-select') {
        return (
          <div className="min-h-screen bg-gradient-to-br from-pacifica-navy to-pacifica-midnight p-8">
            <div className="max-w-2xl mx-auto">
              <div className="bg-white rounded-lg shadow-xl p-8">
                <div className="text-center mb-8">
                  <h1 className="text-4xl font-bold text-pacifica-navy mb-2">Pacifica Christian</h1>
                  <p className="text-xl text-pacifica-slate">Live Grading Assistant</p>
                </div>
                <h2 className="text-2xl font-semibold text-pacifica-navy mb-2">Select Teacher</h2>
                <p className="text-pacifica-slate mb-6">Choose a teacher to begin grading</p>
                {error && (
                  <div className="mb-4 p-4 bg-red-50 border border-red-200 rounded-lg">
                    <p className="text-sm text-red-600">{error}</p>
                  </div>
                )}
                <div className="mb-4">
                  <input
                    type="text"
                    placeholder="Search teachers..."
                    value={teacherQuery}
                    onChange={(e) => setTeacherQuery(e.target.value)}
                    className="w-full px-4 py-2 border-2 border-pacifica-gray rounded-lg focus:ring-2 focus:ring-pacifica-orange focus:border-transparent"
                  />
                </div>
                <div className="space-y-2 max-h-96 overflow-y-auto">
                  {filteredTeachers.map(teacher => (
                    <button
                      key={teacher.id}
                      onClick={() => selectTeacher(teacher)}
                      className="w-full text-left p-4 border-2 border-pacifica-gray rounded-lg hover:bg-pacifica-orange hover:bg-opacity-10 hover:border-pacifica-orange transition-colors"
                    >
                      <p className="font-semibold text-pacifica-navy">{teacher.name}</p>
                      <p className="text-sm text-pacifica-slate">{teacher.email}</p>
                    </button>
                  ))}
                </div>
              </div>
            </div>
          </div>
        );
      }

      if (step === 'section-select') {
        return (
          <div className="min-h-screen bg-gradient-to-br from-pacifica-navy to-pacifica-midnight p-8">
            <div className="max-w-2xl mx-auto">
              <div className="bg-white rounded-lg shadow-xl p-8">
                <button onClick={() => {
                  setStep('teacher-select');
                  setSelectedTeacher(null);
                  setSections([]);
                  setSelectedSections([]);
                  manualTranscriptRequestsRef.current.clear();
                  setManualTranscriptText('');
                  setManualTranscriptError(null);
                  setShowManualTranscriptInput(false);
                  setIsSubmittingTranscript(false);
                  setPendingCount(0);
                }} className="mb-4 text-pacifica-orange hover:text-pacifica-tangerine font-medium flex items-center gap-2">
                  <Icon name="ArrowLeft" className="w-4 h-4" />
                  Back to Teachers
                </button>
                <h1 className="text-3xl font-bold text-pacifica-navy mb-2">Select Sections</h1>
                <p className="text-pacifica-slate mb-2">Teacher: {selectedTeacher?.name}</p>
                <p className="text-sm text-pacifica-orange mb-6 font-medium">
                  {selectedSections.length > 0
                    ? `${selectedSections.length} section(s) selected`
                    : 'Select one or more sections to grade'}
                </p>
                {loading ? (
                  <div className="text-center py-8">
                    <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-pacifica-navy mx-auto mb-4"></div>
                    <p className="text-pacifica-slate">Loading sections...</p>
                  </div>
                ) : (
                  <>
                    <div className="mb-4">
                      <input
                        type="text"
                        placeholder="Search sections..."
                        value={sectionQuery}
                        onChange={(e) => setSectionQuery(e.target.value)}
                        className="w-full px-4 py-2 border-2 border-pacifica-gray rounded-lg focus:ring-2 focus:ring-pacifica-orange focus:border-transparent"
                      />
                    </div>
                    <div className="space-y-2 max-h-96 overflow-y-auto mb-6">
                      {filteredSections.map(section => {
                        const isSelected = selectedSections.find(s => s.id === section.id);
                        return (
                          <button
                            key={section.id}
                            onClick={() => toggleSection(section)}
                            className={`w-full text-left p-4 border rounded-lg transition-all ${isSelected
                              ? 'border-pacifica-orange bg-pacifica-orange/10 shadow-sm ring-1 ring-pacifica-orange/40'
                              : 'border-pacifica-gray hover:border-pacifica-orange hover:bg-pacifica-orange/10'
                              }`}
                          >
                            <div className="flex items-center justify-between">
                              <div>
                                <p className="font-semibold text-pacifica-navy">{section.name}</p>
                                <p className="text-sm text-pacifica-slate">{section.studentCount} students</p>
                              </div>
                              <div className={`w-6 h-6 rounded border flex items-center justify-center ${isSelected ? 'bg-pacifica-orange border-pacifica-orange text-white' : 'border-pacifica-gray text-pacifica-slate'
                                }`}>
                                {isSelected && (
                                  <Icon name="Check" className="w-4 h-4" />
                                )}
                              </div>
                            </div>
                          </button>
                        );
                      })}
                    </div>
                    <button
                      onClick={proceedWithSections}
                      disabled={selectedSections.length === 0}
                      className="w-full px-6 py-3 bg-pacifica-orange text-white font-semibold rounded-lg hover:bg-pacifica-tangerine transition-colors disabled:bg-pacifica-gray disabled:cursor-not-allowed"
                    >
                      Continue with {selectedSections.length} Section{selectedSections.length !== 1 ? 's' : ''}
                    </button>
                  </>
                )}
              </div>
            </div>
          </div>
        );
      }

      if (step === 'assignment-setup') {
        return (
          <div className="min-h-screen bg-gradient-to-br from-pacifica-navy to-pacifica-midnight p-8">
            <div className="max-w-4xl mx-auto">
              <div className="bg-white rounded-lg shadow-xl p-8">
                <button onClick={() => { setStep('section-select'); setSelectedSections([]); setStudents([]); }} className="mb-4 text-pacifica-orange hover:text-pacifica-tangerine font-medium flex items-center gap-2">
                  <Icon name="ArrowLeft" className="w-4 h-4" />
                  Back to Sections
                </button>
                <h1 className="text-3xl font-bold text-pacifica-navy mb-2">Assignment Setup</h1>
                <p className="text-pacifica-slate mb-6">
                  Sections: {selectedSections.map(s => s.name).join(', ')} ({students.length} students)
                </p>

                <div className="mb-6">
                  <label className="block text-sm font-medium text-pacifica-navy mb-2">Assignment Name</label>
                  <input
                    type="text"
                    value={assignmentName}
                    onChange={(e) => setAssignmentName(e.target.value)}
                    placeholder="e.g., Quiz 1, Homework 3"
                    className="w-full px-4 py-2 border-2 border-pacifica-gray rounded-lg focus:ring-2 focus:ring-pacifica-orange focus:border-transparent"
                  />
                </div>

                <div className="mb-6">
                  <div className="flex justify-between items-center mb-4">
                    <label className="block text-sm font-medium text-pacifica-navy">Rubric Items</label>
                    <div className="flex gap-2">
                      <button
                        onClick={openRubricBrowser}
                        className="px-3 py-1 bg-pacifica-robin text-white text-sm rounded-lg hover:bg-pacifica-midnight flex items-center gap-1"
                      >
                        <Icon name="FolderOpen" className="w-4 h-4" />
                        Browse Rubrics
                      </button>
                      <button
                        onClick={() => {
                          const name = prompt('Enter a name for this rubric:');
                          if (name) saveCurrentRubric(name);
                        }}
                        className="px-3 py-1 bg-pacifica-canary text-pacifica-navy text-sm rounded-lg hover:bg-yellow-500 flex items-center gap-1"
                      >
                        <Icon name="Save" className="w-4 h-4" />
                        Save Rubric
                      </button>
                      <button onClick={addRubricItem} className="px-3 py-1 bg-pacifica-orange text-white text-sm rounded-lg hover:bg-pacifica-tangerine flex items-center gap-1">
                        <Icon name="Plus" className="w-4 h-4" />
                        Add Item
                      </button>
                    </div>
                  </div>
                  <div className="space-y-3">
                    {rubricItems.map((item, idx) => (
                      <div key={idx} className="flex gap-3 items-center">
                        <input
                          type="text"
                          value={item.name}
                          onChange={(e) => updateRubricItem(idx, 'name', e.target.value)}
                          placeholder="Criterion name"
                          className="flex-1 px-4 py-2 border-2 border-pacifica-gray rounded-lg focus:ring-2 focus:ring-pacifica-orange focus:border-transparent"
                        />
                        <input
                          type="number"
                          value={item.maxPoints}
                          onChange={(e) => updateRubricItem(idx, 'maxPoints', e.target.value)}
                          placeholder="Points"
                          min="0"
                          className="w-24 px-4 py-2 border-2 border-pacifica-gray rounded-lg focus:ring-2 focus:ring-pacifica-orange focus:border-transparent"
                        />
                        <button
                          onClick={() => removeRubricItem(idx)}
                          disabled={rubricItems.length === 1}
                          className="p-2 text-red-600 hover:bg-red-50 rounded-lg disabled:opacity-30 disabled:cursor-not-allowed"
                        >
                          <Icon name="Trash2" className="w-5 h-5" />
                        </button>
                      </div>
                    ))}
                  </div>
                  <p className="text-sm text-pacifica-slate mt-2">Total Points: {calculateMaxTotal()}</p>
                </div>

                <div className="mb-6">
                  <label className="block text-sm font-medium text-pacifica-navy mb-2">Upload Student PDFs (Optional)</label>
                  <div className="border-2 border-dashed border-pacifica-gray rounded-lg p-6 flex flex-col items-center justify-center text-center hover:bg-pacifica-gray hover:bg-opacity-10 transition-colors">
                    <Icon name="upload" className="w-10 h-10 text-pacifica-slate mb-2" />
                    <p className="text-sm text-pacifica-navy font-semibold mb-1">Drag and drop folder or files here</p>
                    <p className="text-xs text-pacifica-slate mb-4">Filenames should include student ID or Name (e.g. Name_12345.pdf)</p>
                    <input
                      type="file"
                      multiple
                      accept="application/pdf"
                      className="hidden"
                      id="pdf-upload"
                      onChange={handlePDFUpload}
                      webkitdirectory=""
                      directory=""
                    />
                    <label
                      htmlFor="pdf-upload"
                      className="px-4 py-2 bg-pacifica-navy text-white text-sm rounded-lg hover:bg-pacifica-midnight cursor-pointer"
                    >
                      Select Files / Folder
                    </label>
                    <p className="text-xs text-gray-500 mt-2">Note: To upload a folder, you may need to drag and drop it.</p>
                    {uploadedPDFs.length > 0 && (
                      <div className="mt-4 w-full">
                        <div className="flex items-center justify-between mb-2 px-4 py-2 bg-blue-50 rounded border border-blue-100">
                          <span className="text-sm font-semibold text-green-700 flex items-center gap-2">
                            <Icon name="check-circle" className="w-4 h-4" />
                            {uploadedPDFs.length} PDFs Loaded
                          </span>
                          <button onClick={() => setShowPDFMatchReview(true)} className="text-sm text-pacifica-navy font-medium underline hover:text-pacifica-orange">
                            Review Matches
                          </button>
                        </div>
                      </div>
                    )}
                  </div>
                </div>

                <div className="mb-6">
                  <label className="block text-sm font-medium text-pacifica-navy mb-2">
                    Students in Selected Sections ({students.length} total)
                  </label>
                  <div className="space-y-2 max-h-64 overflow-y-auto bg-pacifica-gray bg-opacity-20 rounded-lg p-4">
                    {students.map((student, idx) => (
                      <div key={student.id} className="flex items-center gap-3 bg-white p-3 rounded-lg border border-pacifica-gray">
                        <div className="w-10 h-10 rounded-full bg-pacifica-orange bg-opacity-20 text-pacifica-orange flex items-center justify-center font-semibold">
                          {getInitials(student.name)}
                        </div>
                        <div className="flex-1">
                          <p className="font-medium text-pacifica-navy">{student.name}</p>
                          <p className="text-xs text-pacifica-slate">
                            ID: {student.studentId}
                            {selectedSections.length > 1 && student.sectionName && (
                              <span> • {student.sectionName}</span>
                            )}
                          </p>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>

                <div className="mb-6">
                  <label className="block text-sm font-medium text-pacifica-navy mb-3">Select Grading Mode</label>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <button
                      onClick={() => setGradingMode('voice')}
                      className={`p-6 rounded-lg border-2 transition-all text-left ${gradingMode === 'voice'
                        ? 'border-pacifica-orange bg-pacifica-orange/10 shadow-md'
                        : 'border-pacifica-gray hover:border-pacifica-orange hover:bg-pacifica-orange/5'
                        }`}
                    >
                      <div className="flex items-start gap-4">
                        <div className={`w-12 h-12 rounded-full flex items-center justify-center ${gradingMode === 'voice' ? 'bg-pacifica-orange text-white' : 'bg-pacifica-gray text-pacifica-navy'
                          }`}>
                          <Icon name="Mic" className="w-6 h-6" />
                        </div>
                        <div className="flex-1">
                          <h3 className="font-semibold text-pacifica-navy text-lg mb-1">Voice Grading</h3>
                          <p className="text-sm text-pacifica-slate">
                            Record your voice feedback for each student. Transcripts are automatically processed to extract grades.
                          </p>
                        </div>
                        {gradingMode === 'voice' && (
                          <Icon name="CheckCircle" className="w-6 h-6 text-pacifica-orange" />
                        )}
                      </div>
                    </button>

                    <button
                      onClick={() => setGradingMode('rubric-click')}
                      className={`p-6 rounded-lg border-2 transition-all text-left ${gradingMode === 'rubric-click'
                        ? 'border-pacifica-orange bg-pacifica-orange/10 shadow-md'
                        : 'border-pacifica-gray hover:border-pacifica-orange hover:bg-pacifica-orange/5'
                        }`}
                    >
                      <div className="flex items-start gap-4">
                        <div className={`w-12 h-12 rounded-full flex items-center justify-center ${gradingMode === 'rubric-click' ? 'bg-pacifica-orange text-white' : 'bg-pacifica-gray text-pacifica-navy'
                          }`}>
                          <Icon name="MousePointer" className="w-6 h-6" />
                        </div>
                        <div className="flex-1">
                          <h3 className="font-semibold text-pacifica-navy text-lg mb-1">Click Rubric Grading</h3>
                          <p className="text-sm text-pacifica-slate">
                            Quickly grade students by clicking pre-calculated score options for each rubric item.
                          </p>
                        </div>
                        {gradingMode === 'rubric-click' && (
                          <Icon name="CheckCircle" className="w-6 h-6 text-pacifica-orange" />
                        )}
                      </div>
                    </button>
                  </div>
                </div>

                <button
                  onClick={() => startGradingSession(gradingMode)}
                  disabled={!assignmentName.trim()}
                  className="w-full py-3 bg-pacifica-orange text-white font-semibold rounded-lg hover:bg-pacifica-tangerine disabled:bg-pacifica-gray disabled:cursor-not-allowed transition-colors"
                >
                  Start {gradingMode === 'voice' ? 'Voice' : 'Click Rubric'} Grading Session
                </button>
              </div>
            </div>

            {showRubricBrowser && (
              <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                <div className="bg-white rounded-lg max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col">
                  <div className="bg-gradient-to-r from-pacifica-navy to-pacifica-midnight p-6 text-white">
                    <div className="flex items-center justify-between mb-4">
                      <h2 className="text-2xl font-bold">Browse Rubrics</h2>
                      <button
                        onClick={() => setShowRubricBrowser(false)}
                        className="p-2 hover:bg-white hover:bg-opacity-20 rounded-lg transition-colors"
                      >
                        <Icon name="X" className="w-6 h-6" />
                      </button>
                    </div>

                    <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                      <input
                        type="text"
                        placeholder="Search rubrics by name..."
                        value={rubricSearchQuery}
                        onChange={(e) => setRubricSearchQuery(e.target.value)}
                        className="px-4 py-2 rounded-lg text-pacifica-navy focus:ring-2 focus:ring-white focus:outline-none"
                      />
                      <select
                        value={rubricFilterTeacher?.id || ''}
                        onChange={(e) => {
                          if (e.target.value === '') {
                            setRubricFilterTeacher(null);
                          } else {
                            const teacher = teachers.find(t => t.id === e.target.value);
                            setRubricFilterTeacher(teacher);
                          }
                        }}
                        className="px-4 py-2 rounded-lg text-pacifica-navy focus:ring-2 focus:ring-white focus:outline-none"
                      >
                        <option value="">All Teachers</option>
                        <option value={selectedTeacher.id}>My Rubrics ({selectedTeacher.name})</option>
                        {teachers.filter(t => t.id !== selectedTeacher.id).map(teacher => (
                          <option key={teacher.id} value={teacher.id}>
                            {teacher.name}
                          </option>
                        ))}
                      </select>
                    </div>
                  </div>

                  <div className="flex-1 overflow-y-auto p-6">
                    {getFilteredRubrics().length === 0 ? (
                      <div className="text-center py-12">
                        <Icon name="FolderOpen" className="w-16 h-16 text-pacifica-gray mx-auto mb-4" />
                        <p className="text-pacifica-slate text-lg mb-2">No rubrics found</p>
                        <p className="text-pacifica-gray text-sm">
                          {rubricSearchQuery || rubricFilterTeacher
                            ? 'Try adjusting your search or filter'
                            : 'Create your first rubric by clicking "Save Rubric" below'}
                        </p>
                      </div>
                    ) : (
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        {getFilteredRubrics().map(rubric => {
                          const isMyRubric = rubric.teacherIds.includes(selectedTeacher.id);
                          return (
                            <div
                              key={rubric.id}
                              className="border-2 border-pacifica-gray rounded-lg p-4 hover:border-pacifica-orange hover:shadow-md transition-all"
                            >
                              <div className="flex items-start justify-between mb-3">
                                <div className="flex-1">
                                  <h3 className="font-semibold text-pacifica-navy text-lg mb-1">{rubric.name}</h3>
                                  <div className="flex items-center gap-2 text-sm text-pacifica-slate">
                                    <Icon name="User" className="w-4 h-4" />
                                    <span>{rubric.teacherNames.join(', ')}</span>
                                  </div>
                                  {isMyRubric && (
                                    <span className="inline-block mt-1 px-2 py-0.5 bg-green-100 text-green-700 text-xs rounded-full">
                                      My Rubric
                                    </span>
                                  )}
                                </div>
                              </div>

                              <div className="bg-pacifica-gray bg-opacity-20 rounded-lg p-3 mb-3">
                                <p className="text-xs font-semibold text-pacifica-navy mb-2">{rubric.items.length} items:</p>
                                <div className="space-y-1">
                                  {rubric.items.slice(0, 3).map((item, idx) => (
                                    <div key={idx} className="flex justify-between text-xs text-pacifica-navy">
                                      <span className="truncate">{item.name}</span>
                                      <span className="font-medium ml-2">{item.maxPoints}pts</span>
                                    </div>
                                  ))}
                                  {rubric.items.length > 3 && (
                                    <p className="text-xs text-pacifica-slate italic">
                                      +{rubric.items.length - 3} more items...
                                    </p>
                                  )}
                                </div>
                                <div className="mt-2 pt-2 border-t border-pacifica-gray">
                                  <p className="text-xs font-semibold text-pacifica-navy">
                                    Total: {rubric.items.reduce((sum, item) => sum + item.maxPoints, 0)} points
                                  </p>
                                </div>
                              </div>

                              <div className="flex gap-2">
                                <button
                                  onClick={() => loadRubric(rubric)}
                                  className="flex-1 px-3 py-2 bg-pacifica-orange text-white text-sm font-medium rounded-lg hover:bg-pacifica-tangerine transition-colors flex items-center justify-center gap-1"
                                >
                                  <Icon name="Download" className="w-4 h-4" />
                                  Load
                                </button>
                                {isMyRubric && (
                                  <button
                                    onClick={() => deleteRubric(rubric.id, rubric.name)}
                                    className="px-3 py-2 bg-red-100 text-red-600 text-sm font-medium rounded-lg hover:bg-red-200 transition-colors"
                                  >
                                    <Icon name="Trash2" className="w-4 h-4" />
                                  </button>
                                )}
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    )}
                  </div>

                  <div className="border-t border-pacifica-gray p-4 bg-pacifica-gray bg-opacity-10">
                    <div className="flex justify-between items-center">
                      <p className="text-sm text-pacifica-slate">
                        Showing {getFilteredRubrics().length} of {allRubrics.length} rubrics
                      </p>
                      <button
                        onClick={() => setShowRubricBrowser(false)}
                        className="px-4 py-2 bg-pacifica-gray text-pacifica-navy font-medium rounded-lg hover:bg-opacity-60 transition-colors"
                      >
                        Close
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      }

      if (step === 'grading') {
        const pdfMatch = currentGradingStudentId
          ? uploadedPDFs.find(p => p.studentId === currentGradingStudentId && p.method !== 'Unmatched')
          : null;

        // Should ensure we have a current student selected if possible, or handle null
        const currentGradingStudent = students.find(s => s.studentId === currentGradingStudentId || s.id === currentGradingStudentId);

        // Access orderedStudents from outer scope or re-derive if needed
        // Assuming orderedStudents is available in scope as it was for rubric-click-grading
        // If not, we fall back to 'students' array
        const studentList = typeof orderedStudents !== 'undefined' ? orderedStudents : students;

        const currentIndex = currentGradingStudent ? studentList.findIndex(s => s.id === currentGradingStudent.id) : -1;
        const prevStudent = currentIndex > 0 ? studentList[currentIndex - 1] : null;
        const nextStudent = currentIndex !== -1 && currentIndex < studentList.length - 1 ? studentList[currentIndex + 1] : null;

        const renderVoiceContent = (isSidebar) => {
          const header = !isSidebar ? (
            <div className="bg-white rounded-lg shadow-md border border-pacifica-gray p-4 mb-6">
              <div className="flex items-center justify-between">
                <div>
                  <h1 className="text-2xl font-bold text-pacifica-navy">{assignmentName}</h1>
                  <p className="text-sm text-pacifica-slate">{selectedTeacher?.name} • {selectedSections.map(s => s.name).join(', ')}</p>
                </div>
                <div className="flex items-center gap-4">
                  {pendingCount > 0 && (
                    <div className="flex items-center gap-2 px-3 py-1 bg-pacifica-tangerine bg-opacity-20 text-pacifica-tangerine rounded-full text-sm font-medium">
                      <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-pacifica-tangerine"></div>
                      {pendingCount} processing
                    </div>
                  )}
                  <button
                    onClick={() => setStep('review')}
                    disabled={Object.values(grades).filter(g => g.completed).length === 0}
                    className="px-4 py-2 bg-pacifica-orange text-white font-semibold rounded-lg hover:bg-pacifica-tangerine disabled:bg-pacifica-gray disabled:cursor-not-allowed transition-colors flex items-center gap-2"
                  >
                    <Icon name="ClipboardCheck" className="w-4 h-4" />
                    Review & Upload
                  </button>
                  <button
                    onClick={async () => {
                      if (confirm('Exit grading session? Unsaved grades will be lost.')) {
                        if (isRecording) {
                          if (mediaStreamRef.current) {
                            mediaStreamRef.current.getTracks().forEach(track => track.stop());
                          }
                          setIsRecording(false);
                        }
                        setStep('assignment-setup');
                      }
                    }}
                    className="px-4 py-2 bg-pacifica-slate text-white font-semibold rounded-lg hover:bg-pacifica-midnight transition-colors"
                  >
                    Exit Session
                  </button>
                </div>
              </div>
              {error && (
                <div className="mt-4 p-3 bg-red-50 border border-red-200 rounded-lg">
                  <p className="text-sm text-red-600">{error}</p>
                </div>
              )}
            </div>
          ) : null;

          return (
            <div className={`${isSidebar ? 'p-4' : 'max-w-7xl mx-auto'}`}>
              {header}


              {/* Standard Main Content */}
              <div className={`grid ${isSidebar ? 'grid-cols-1' : 'grid-cols-3'} gap-6`}>
                <div className="space-y-6">
                  <div className="bg-white rounded-lg shadow-md border border-pacifica-gray p-6">
                    <h2 className="text-lg font-semibold text-pacifica-navy mb-4">Recording Controls</h2>
                    <div className="flex flex-col items-center gap-4">
                      {!isRecording ? (
                        <button
                          onClick={startRecording}
                          className="w-20 h-20 rounded-full bg-pacifica-orange hover:bg-pacifica-tangerine flex items-center justify-center transition-all shadow-lg"
                        >
                          <Icon name="Mic" className="w-8 h-8 text-white" />
                        </button>
                      ) : (
                        <div className="flex gap-3">
                          {isPaused ? (
                            <button
                              onClick={resumeRecording}
                              className="w-16 h-16 rounded-full bg-green-600 hover:bg-green-700 flex items-center justify-center transition-all shadow-lg"
                            >
                              <Icon name="Play" className="w-6 h-6 text-white" />
                            </button>
                          ) : (
                            <button
                              onClick={pauseRecording}
                              className="w-16 h-16 rounded-full bg-pacifica-canary hover:bg-yellow-500 flex items-center justify-center transition-all shadow-lg"
                            >
                              <Icon name="Pause" className="w-6 h-6 text-pacifica-navy" />
                            </button>
                          )}
                          <button
                            onClick={finishRecording}
                            className="w-16 h-16 rounded-full bg-red-600 hover:bg-red-700 flex items-center justify-center transition-all shadow-lg"
                          >
                            <Icon name="Square" className="w-6 h-6 text-white" />
                          </button>
                        </div>
                      )}
                      <div className="text-center w-full">
                        <p className="text-sm font-medium text-pacifica-navy">
                          {!isRecording ? 'Ready to Record' : isPaused ? 'Paused' : 'Recording...'}
                        </p>
                        <p className="text-2xl font-mono text-pacifica-slate mt-2">{formatTime(recordingTime)}</p>
                        {currentStudent && <p className="text-sm text-pacifica-orange font-medium mt-2">Currently: {currentStudent}</p>}
                        {micError && <p className="text-xs text-red-600 mt-2">{micError}</p>}
                      </div>
                      {isRecording && !isPaused && (
                        <div className="mt-2 p-3 bg-pacifica-orange bg-opacity-10 rounded-lg border border-pacifica-orange w-full">
                          <p className="text-xs font-semibold text-pacifica-navy mb-1">How to use:</p>
                          <p className="text-xs text-pacifica-slate">
                            🎤 Speak about one student<br />
                            ⌨️ Press SPACE to finish & start next<br />
                            ⏸️ Pause when needed<br />
                            ⏹️ Finish to end session<br />
                            💾 Download recordings anytime
                          </p>
                        </div>
                      )}
                    </div>
                  </div>

                  <div className="bg-white rounded-lg shadow-md border border-pacifica-gray p-6">
                    <h2 className="text-lg font-semibold text-pacifica-navy mb-4">Rubric Reference</h2>
                    <div className="space-y-2">
                      {rubricItems.map((item, idx) => (
                        <div key={idx} className="flex justify-between">
                          <span className="text-sm text-pacifica-slate">{item.name}</span>
                          <span className="text-sm font-semibold text-pacifica-navy">/{item.maxPoints}</span>
                        </div>
                      ))}
                      <div className="pt-2 border-t border-pacifica-gray flex justify-between">
                        <span className="text-sm font-semibold text-pacifica-navy">Total</span>
                        <span className="text-sm font-bold text-pacifica-orange">/{calculateMaxTotal()}</span>
                      </div>
                    </div>
                  </div>

                  <div className="bg-white rounded-lg shadow-md border border-pacifica-gray p-6">
                    <div className="flex items-center justify-between mb-4">
                      <h2 className="text-lg font-semibold text-pacifica-navy">Recording Segments ({recordingSegments.length})</h2>
                      {recordingSegments.length > 0 && (
                        <button
                          onClick={downloadAllRecordings}
                          className="px-3 py-1 bg-pacifica-orange text-white text-sm rounded hover:bg-pacifica-tangerine flex items-center gap-1"
                        >
                          <Icon name="Download" className="w-4 h-4" />
                          Download All
                        </button>
                      )}
                    </div>
                    {recordingSegments.length === 0 ? (
                      <p className="text-sm text-pacifica-gray italic">No recordings yet. Press SPACEBAR to finish first segment.</p>
                    ) : (
                      <div className="flex flex-wrap gap-2 max-h-32 overflow-y-auto">
                        {recordingSegments.map((segment) => (
                          <div
                            key={segment.id}
                            onClick={() => {
                              const recording = completedRecordingsRef.current.find(r => r.id === segment.id);
                              if (recording) downloadRecording(recording);
                            }}
                            className={`px-3 py-2 rounded-lg border cursor-pointer transition-all hover:shadow-md ${segment.status === 'completed' ? 'bg-green-50 border-green-300' :
                              segment.status === 'processing' ? 'bg-pacifica-canary bg-opacity-20 border-pacifica-canary animate-pulse' :
                                segment.status === 'error' ? 'bg-red-50 border-red-300' :
                                  'bg-pacifica-gray bg-opacity-20 border-pacifica-gray'
                              }`}
                            title="Click to download"
                          >
                            <div className="flex items-center gap-2">
                              <Icon name={
                                segment.status === 'completed' ? 'CheckCircle' :
                                  segment.status === 'processing' ? 'Loader' :
                                    segment.status === 'error' ? 'XCircle' :
                                      'HelpCircle'
                              } className="w-4 h-4" />
                              <div>
                                <p className="text-xs font-semibold text-pacifica-navy">
                                  {segment.studentName || `Segment ${segment.chunkNumber}`}
                                </p>
                                <p className="text-xs text-pacifica-slate">
                                  {(segment.duration / 1000).toFixed(1)}s • {Math.round(segment.size / 1024)}KB
                                </p>
                              </div>
                            </div>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>

                </div>

                <div className="space-y-4 mb-6">
                  {rubricItems.map((item, idx) => {
                    const scoreOptions = calculateRubricScoreOptions(item.maxPoints);
                    const currentScore = currentGrade?.scores[item.name];

                    return (
                      <div key={idx} className="bg-white rounded-lg shadow-md border border-pacifica-gray p-6">
                        <div className="flex items-center justify-between mb-4">
                          <h3 className="text-lg font-semibold text-pacifica-navy">{item.name}</h3>
                          <span className="text-sm text-pacifica-slate">Max: {item.maxPoints} points</span>
                        </div>

                        <div className="grid grid-cols-6 gap-3 mb-3">
                          {scoreOptions.map((score) => (
                            <button
                              key={score}
                              onClick={() => updateRubricClickScore(currentGradingStudentId, item.name, score)}
                              className={`p-4 rounded-lg border-2 transition-all ${currentScore === score
                                ? 'border-pacifica-orange bg-pacifica-orange text-white shadow-lg scale-105'
                                : 'border-pacifica-gray bg-white text-pacifica-navy hover:border-pacifica-orange hover:bg-pacifica-orange/10'
                                }`}
                            >
                              <div className="text-2xl font-bold">{score}</div>
                              <div className="text-xs mt-1 opacity-80">
                                {score === 0 ? '0%' : score === item.maxPoints ? '100%' : `${Math.round((score / item.maxPoints) * 100)}%`}
                              </div>
                            </button>
                          ))}
                        </div>

                        <div className="flex items-center gap-2">
                          <label className="text-sm text-pacifica-slate">Custom:</label>
                          <input
                            key={`${currentGradingStudentId}-${item.name}`}
                            type="number"
                            step="0.01"
                            min="0"
                            max={item.maxPoints}
                            defaultValue={currentScore === undefined ? '' : currentScore}
                            onChange={(e) => {
                              const val = parseFloat(e.target.value);
                              if (!isNaN(val) && val >= 0 && val <= item.maxPoints) {
                                updateRubricClickScore(currentGradingStudentId, item.name, val);
                              } else if (e.target.value === '') {
                                updateRubricClickScore(currentGradingStudentId, item.name, 0);
                              }
                            }}
                            placeholder={`0-${item.maxPoints}`}
                            className="w-20 px-3 py-2 border-2 border-pacifica-gray rounded-lg focus:ring-2 focus:ring-pacifica-orange focus:border-pacifica-orange text-sm text-center"
                          />
                          <span className="text-xs text-pacifica-slate">/ {item.maxPoints}</span>
                        </div>
                      </div>
                    );
                  })}
                </div>

                {/* Comments */}
                <div className="bg-white rounded-lg shadow-md border border-pacifica-gray p-6 mb-6">
                  <label className="block text-sm font-semibold text-pacifica-navy mb-2">
                    Comments (Optional)
                  </label>
                  <textarea
                    value={currentGrade?.comments || ''}
                    onChange={(e) => {
                      setGrades(prev => ({
                        ...prev,
                        [currentGradingStudentId]: {
                          ...prev[currentGradingStudentId],
                          comments: e.target.value
                        }
                      }));
                    }}
                    rows={4}
                    placeholder="Add any additional comments for this student..."
                    className="w-full px-4 py-3 border-2 border-pacifica-gray rounded-lg focus:ring-2 focus:ring-pacifica-orange focus:border-transparent text-sm"
                  />
                </div>

                {/* Action Buttons */}
                <div className="flex gap-3">
                  {!currentGrade?.completed ? (
                    <button
                      onClick={completeCurrentStudent}
                      className="flex-1 px-6 py-3 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700 transition-colors flex items-center justify-center gap-2"
                    >
                      <Icon name="CheckCircle" className="w-5 h-5" />
                      Complete & Next Student
                    </button>
                  ) : (
                    <button
                      onClick={() => {
                        setGrades(prev => ({
                          ...prev,
                          [currentGradingStudentId]: {
                            ...prev[currentGradingStudentId],
                            completed: false
                          }
                        }));
                      }}
                      className="flex-1 px-6 py-3 bg-pacifica-canary text-pacifica-navy font-semibold rounded-lg hover:bg-yellow-500 transition-colors flex items-center justify-center gap-2"
                    >
                      <Icon name="Edit" className="w-5 h-5" />
                      Mark as Incomplete
                    </button>
                  )}

                </div>

                <div className="bg-white rounded-lg shadow-md border border-pacifica-gray p-6 col-span-2">
                  <div className="flex items-center justify-between mb-4 gap-3">
                    <h2 className="text-lg font-semibold text-pacifica-navy">Transcript (Newest First)</h2>
                    <button
                      onClick={() => {
                        setManualTranscriptError(null);
                        setShowManualTranscriptInput(prev => !prev);
                      }}
                      className="btn btn-outline"
                    >
                      <Icon name={showManualTranscriptInput ? 'Minus' : 'FileText'} className="w-4 h-4" />
                      {showManualTranscriptInput ? 'Close' : 'Paste Transcript'}
                    </button>
                  </div>

                  {showManualTranscriptInput && (
                    <div className="mb-4 p-4 border border-pacifica-gray rounded-lg bg-pacifica-gray bg-opacity-10 animate-fadeIn">
                      {/* Reduced manual transcript input logic here to save space as it's huge, 
                                 or I should reuse it. I'll paste the original logic back simplified or full. 
                                 I'll assume FULL content for correctness. 
                             */}
                      <label className="block text-sm font-semibold text-pacifica-navy mb-2" htmlFor="manual-transcript-input">
                        Paste or type transcript text
                      </label>
                      <textarea
                        id="manual-transcript-input"
                        ref={manualTranscriptInputRef}
                        value={manualTranscriptText}
                        onChange={(e) => setManualTranscriptText(e.target.value)}
                        rows={6}
                        className="w-full p-3 border border-pacifica-gray rounded-lg focus:ring-2 focus:ring-pacifica-orange focus:border-pacifica-orange text-sm"
                        placeholder="Paste or type transcript content here..."
                        autoFocus
                        disabled={isSubmittingTranscript}
                      ></textarea>
                      {/* ... buttons ... */}
                      <div className="flex justify-end gap-2 mt-4">
                        <button
                          onClick={() => {
                            setShowManualTranscriptInput(false);
                            setManualTranscriptText('');
                            setManualTranscriptError(null);
                          }}
                          className="btn btn-outline"
                          disabled={isSubmittingTranscript}
                        >
                          Cancel
                        </button>
                        <button
                          onClick={submitManualTranscript}
                          className="btn btn-primary"
                          disabled={isSubmittingTranscript}
                        >
                          {isSubmittingTranscript ? 'Submitting...' : 'Submit Transcript'}
                        </button>
                      </div>
                    </div>
                  )}

                  <div className="h-96 overflow-y-auto bg-pacifica-gray bg-opacity-10 rounded p-4 text-sm space-y-3">
                    {transcript.length === 0 ? (
                      <p className="text-pacifica-gray italic">{isRecording ? 'Press SPACEBAR to process...' : 'Start recording'}</p>
                    ) : (
                      transcript.map((entry) => (
                        <div
                          key={entry.id}
                          className={`p-3 rounded-lg border ${entry.isProcessing
                            ? 'bg-pacifica-canary bg-opacity-10 border-pacifica-canary animate-pulse'
                            : 'bg-white border-pacifica-gray'
                            }`}
                        >
                          {entry.timestamp && (
                            <div className="text-xs text-pacifica-slate mb-1 font-mono">{entry.timestamp}</div>
                          )}
                          <p className="text-pacifica-navy whitespace-pre-line leading-relaxed">{entry.text}</p>
                        </div>
                      ))
                    )}
                  </div>
                </div>
              </div>
            </div >


          );
        };

        if (pdfMatch && currentGradingStudent) {
          return (
            <div className="flex h-screen overflow-hidden bg-gray-100">
              <div className="flex-1 relative border-r border-gray-300 bg-gray-200 overflow-hidden">
                <PDFViewer
                  file={pdfMatch.file}
                  pageNumber={pdfPage}
                  scale={pdfScale}
                  onPageChange={setPdfPage}
                  onScaleChange={setPdfScale}
                />
                <div className="absolute top-4 left-4 z-20">
                  <button
                    onClick={() => {
                      if (confirm('Exit grading session?')) setStep('assignment-setup');
                    }}
                    className="p-2 bg-white rounded-full shadow-md hover:bg-gray-100 text-gray-600 flex items-center justify-center transition-colors"
                    title="Exit"
                  >
                    <Icon name="ArrowLeft" className="w-5 h-5" />
                  </button>
                </div>
              </div>

              <div className="w-[450px] flex flex-col bg-white shadow-xl z-10 h-full border-l border-gray-200">
                <div className="p-4 border-b bg-gray-50 flex items-center justify-between shrink-0">
                  <button
                    onClick={() => prevStudent && setCurrentGradingStudentId(prevStudent.id)}
                    disabled={!prevStudent}
                    className="p-2 hover:bg-white rounded-full transition-colors disabled:opacity-30 disabled:cursor-not-allowed text-pacifica-navy"
                  >
                    <Icon name="ChevronLeft" className="w-6 h-6" />
                  </button>

                  <div className="text-center">
                    <h3 className="font-bold text-pacifica-navy truncate max-w-[200px]">{currentGradingStudent.name}</h3>
                    <p className="text-xs text-pacifica-slate">{currentIndex + 1} of {students.length}</p>
                  </div>

                  <button
                    onClick={() => nextStudent && setCurrentGradingStudentId(nextStudent.id)}
                    disabled={!nextStudent}
                    className="p-2 hover:bg-white rounded-full transition-colors disabled:opacity-30 disabled:cursor-not-allowed text-pacifica-navy"
                  >
                    <Icon name="ChevronRight" className="w-6 h-6" />
                  </button>
                </div>

                <div className="flex-1 overflow-y-auto">
                  {renderVoiceContent(true)}
                </div>
              </div>
            </div>
          );
        }

        return (
          <div className="min-h-screen bg-pacifica-gray bg-opacity-10 p-6">
            {renderVoiceContent(false)}
          </div>
        );
      }

      if (step === 'rubric-click-grading') {
        const currentGradingStudent = students.find(s => s.id === currentGradingStudentId);
        const currentGrade = currentGradingStudent ? grades[currentGradingStudentId] || { scores: {}, comments: '', completed: false } : null;
        const allGraded = students.every(s => grades[s.id]?.completed);
        const gradedCount = students.filter(s => grades[s.id]?.completed).length;

        // PDF Match Check
        const pdfMatch = currentGradingStudent ? uploadedPDFs.find(p => p.studentId === currentGradingStudent.studentId && p.method !== 'Unmatched') : null;

        // Navigation Helpers
        const currentIndex = currentGradingStudent ? orderedStudents.findIndex(s => s.id === currentGradingStudent.id) : -1;
        const prevStudent = currentIndex > 0 ? orderedStudents[currentIndex - 1] : null;
        const nextStudent = currentIndex !== -1 && currentIndex < orderedStudents.length - 1 ? orderedStudents[currentIndex + 1] : null;

        if (pdfMatch && currentGradingStudent) {
          return (
            <div className="flex h-screen overflow-hidden bg-gray-100">
              <div className="flex-1 relative border-r border-gray-300 bg-gray-200 overflow-hidden">
                <PDFViewer
                  file={pdfMatch.file}
                  pageNumber={pdfPage}
                  scale={pdfScale}
                  onPageChange={setPdfPage}
                  onScaleChange={setPdfScale}
                />
                <div className="absolute top-4 left-4 z-20">
                  <button
                    onClick={() => {
                      if (confirm('Exit grading session?')) {
                        setStep('assignment-setup');
                      }
                    }}
                    className="p-2 bg-white rounded-full shadow-md hover:bg-gray-100 text-gray-600 flex items-center justify-center transition-colors"
                    title="Exit"
                  >
                    <Icon name="ArrowLeft" className="w-5 h-5" />
                  </button>
                </div>
              </div>

              <div className="w-[450px] flex flex-col bg-white shadow-xl z-10 h-full border-l border-gray-200">
                <div className="p-4 border-b bg-gray-50 flex items-center justify-between shrink-0">
                  <button
                    onClick={() => prevStudent && setCurrentGradingStudentId(prevStudent.id)}
                    disabled={!prevStudent}
                    className="p-2 hover:bg-white rounded-full transition-colors disabled:opacity-30 disabled:cursor-not-allowed text-pacifica-navy"
                  >
                    <Icon name="ChevronLeft" className="w-6 h-6" />
                  </button>

                  <div className="text-center">
                    <h3 className="font-bold text-pacifica-navy truncate max-w-[200px]">{currentGradingStudent.name}</h3>
                    <p className="text-xs text-pacifica-slate">
                      {currentIndex + 1} of {students.length}
                    </p>
                  </div>

                  <button
                    onClick={() => nextStudent && setCurrentGradingStudentId(nextStudent.id)}
                    disabled={!nextStudent}
                    className="p-2 hover:bg-white rounded-full transition-colors disabled:opacity-30 disabled:cursor-not-allowed text-pacifica-navy"
                  >
                    <Icon name="ChevronRight" className="w-6 h-6" />
                  </button>
                </div>

                {renderVoiceContent(true)}
              </div>
            </div>
          );
        }

        return (
          <div className="min-h-screen bg-pacifica-gray bg-opacity-10 flex">
            <div className="w-80 bg-white border-r border-pacifica-gray flex flex-col h-screen fixed left-0 top-0 bottom-0 z-10">
              <div className="p-4 border-b border-pacifica-gray bg-gradient-to-r from-pacifica-navy to-pacifica-midnight shrink-0">
                <h2 className="text-lg font-bold text-white">{assignmentName}</h2>
                <p className="text-sm text-pacifica-gray">Click Rubric Grading</p>
                <p className="text-xs text-white mt-1">{gradedCount}/{students.length} graded</p>
                <button
                  onClick={() => setStep('review')}
                  className="mt-3 w-full px-3 py-2 bg-pacifica-orange text-white text-sm font-medium rounded-lg hover:bg-pacifica-tangerine transition-colors flex items-center justify-center gap-2"
                >
                  <Icon name="ClipboardCheck" className="w-4 h-4" />
                  Review & Upload ({gradedCount})
                </button>
              </div>

              <div className="flex-1 overflow-y-auto p-3 space-y-2">
                {orderedStudents.map((student) => {
                  const sg = grades[student.id] || { scores: {}, comments: '', completed: false };
                  const total = calculateTotal(sg);
                  const isCurrentStudent = currentGradingStudentId === student.id;

                  return (
                    <button
                      key={student.id}
                      onClick={() => setCurrentGradingStudentId(student.id)}
                      className={`w-full text-left p-3 rounded-lg border-2 transition-all ${isCurrentStudent
                        ? 'border-pacifica-orange bg-pacifica-orange/10 shadow-md'
                        : sg.completed
                          ? 'border-green-300 bg-green-50 hover:border-green-400'
                          : 'border-pacifica-gray bg-white hover:border-pacifica-orange'
                        }`}
                    >
                      <div className="flex items-center justify-between">
                        <div className="flex items-center gap-2 min-w-0 flex-1">
                          <div className={`w-8 h-8 rounded-full flex items-center justify-center text-xs font-semibold flex-shrink-0 ${sg.completed ? 'bg-green-600 text-white' : 'bg-pacifica-gray text-pacifica-navy'
                            }`}>
                            {sg.completed ? <Icon name="Check" className="w-4 h-4" /> : getInitials(student.name)}
                          </div>
                          <div className="min-w-0 flex-1">
                            <p className="font-medium text-pacifica-navy text-sm truncate">{student.name}</p>
                            <p className="text-xs text-pacifica-slate truncate">ID: {student.studentId}</p>
                          </div>
                        </div>
                        <div className="text-right ml-2">
                          {sg.completed ? (
                            <>
                              <p className="text-lg font-bold text-pacifica-navy">{total}</p>
                              <p className="text-xs text-pacifica-slate">/{calculateMaxTotal()}</p>
                            </>
                          ) : (
                            <p className="text-xs text-pacifica-slate">Not graded</p>
                          )}
                        </div>
                      </div>
                    </button>
                  );
                })}
              </div>

              <div className="p-3 border-t border-pacifica-gray bg-pacifica-gray/20 shrink-0">
                <button
                  onClick={() => {
                    if (confirm('Exit grading session? Unsaved grades will be lost.')) {
                      setStep('assignment-setup');
                    }
                  }}
                  className="w-full px-3 py-2 bg-pacifica-slate text-white font-medium rounded-lg hover:bg-pacifica-midnight transition-colors text-sm"
                >
                  Exit Session
                </button>
              </div>
            </div>

            <div className="flex-1 ml-80 min-h-screen">
              {renderVoiceContent(false)}
            </div>
          </div>
        );
      }

      if (step === 'review') {
        const completedCount = Object.values(grades).filter(g => g.completed).length;
        const maxTotal = calculateMaxTotal();
        const hasSelectedEmailRecipients = selectedEmailStudentIds.length > 0;

        return (
          <div className="min-h-screen bg-pacifica-gray bg-opacity-10 p-6">
            <div className="max-w-7xl mx-auto">
              <div className="bg-white rounded-lg shadow-md border border-pacifica-gray p-6 mb-6">
                <div className="flex items-center justify-between">
                  <div>
                    <h1 className="text-3xl font-bold text-pacifica-navy">Review Grades - {assignmentName}</h1>
                    <p className="text-pacifica-slate mt-1">{selectedTeacher?.name} • {selectedSections.map(s => s.name).join(', ')}</p>
                    <p className="text-sm text-pacifica-slate mt-1">
                      {completedCount} of {students.length} students graded • Max Points: {maxTotal}
                    </p>
                  </div>
                  <div className="flex flex-col items-end gap-3">
                    {uploadComplete ? (
                      <div className="flex items-center gap-3 bg-green-50 border border-green-300 rounded-lg px-6 py-4">
                        <Icon name="check-circle" className="w-8 h-8 text-green-600" />
                        <div>
                          <p className="text-lg font-bold text-green-800">Upload Complete!</p>
                          <p className="text-sm text-green-700">Grades saved to Airtable</p>
                        </div>
                      </div>
                    ) : (
                      <div className="flex gap-3">
                        <button
                          onClick={() => setStep(gradingMode === 'rubric-click' ? 'rubric-click-grading' : 'grading')}
                          className="btn btn-outline"
                        >
                          Back to Grading
                        </button>

                        <button
                          onClick={handleDraftEmail}
                          disabled={isDraftingEmail || completedCount === 0 || !hasSelectedEmailRecipients}
                          className="btn btn-primary"
                          title={completedCount === 0
                            ? 'No graded students yet'
                            : !hasSelectedEmailRecipients
                              ? 'Select at least one graded student to draft emails'
                              : 'Draft emails for selected students'}
                        >
                          {isDraftingEmail ? (
                            <>
                              <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                              Drafting…
                            </>
                          ) : (
                            <>
                              <Icon name="mail" className="w-5 h-5" />
                              Draft Emails
                            </>
                          )}
                        </button>

                        <button
                          onClick={uploadGradesToAirtable}
                          disabled={isUploading || completedCount === 0}
                          className="btn btn-primary"
                        >
                          {isUploading ? (
                            <>
                              <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                              Uploading {uploadProgress.current}/{uploadProgress.total}
                            </>
                          ) : (
                            <>
                              <Icon name="upload" className="w-5 h-5" />
                              Upload to Airtable
                            </>
                          )}
                        </button>
                      </div>
                    )}

                    <div className="flex items-center gap-2">
                      {uploadComplete && (
                        <>
                          <button
                            onClick={handleDraftEmail}
                            disabled={isDraftingEmail || completedCount === 0 || !hasSelectedEmailRecipients}
                            className="btn btn-primary"
                          >
                            {isDraftingEmail ? (
                              <>
                                <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                                Drafting…
                              </>
                            ) : (
                              <>
                                <Icon name="mail" className="w-4 h-4" />
                                Draft Emails
                              </>
                            )}
                          </button>

                          <button
                            onClick={() => {
                              setStep('teacher-select');
                              setSelectedTeacher(null);
                              setSelectedSections([]);
                              setStudents([]);
                              setStudentOrder([]);
                              setGrades({});
                              setTranscript([]);
                              setRecordingSegments([]);
                              completedRecordingsRef.current = [];
                              setUploadComplete(false);
                              setAssignmentName('');
                              setSessionId(null);
                              setRubricItems([
                                { name: 'Correctness', maxPoints: 25 },
                                { name: 'Method', maxPoints: 25 },
                                { name: 'Clarity', maxPoints: 25 },
                                { name: 'Completeness', maxPoints: 25 }
                              ]);
                              setCurrentStudent(null);
                              setError(null);
                              setSelectedEmailStudentIds([]);
                              manualTranscriptRequestsRef.current.clear();
                              setManualTranscriptText('');
                              setManualTranscriptError(null);
                              setShowManualTranscriptInput(false);
                              setIsSubmittingTranscript(false);
                              setPendingCount(0);
                            }}
                            className="btn btn-outline"
                          >
                            <Icon name="plus-circle" className="w-5 h-5" />
                            Start New Session
                          </button>
                        </>
                      )}

                      {transcript.length > 0 && (
                        <button onClick={downloadTranscript} className="btn btn-outline">
                          <Icon name="file-text" className="w-4 h-4" />
                          Download Transcript
                        </button>
                      )}

                      {recordingSegments.length > 0 && (
                        <button onClick={downloadAllRecordings} className="btn btn-outline">
                          <Icon name="download" className="w-4 h-4" />
                          Download Recordings
                        </button>
                      )}
                    </div>
                  </div>
                </div>
              </div>

              {emailDraftSuccess && (
                <div className="mb-4 p-3 border border-green-300 bg-green-50 rounded-lg text-green-800 flex items-center gap-2">
                  <Icon name="check-circle" className="w-5 h-5 text-green-600" />
                  <span>Email draft sent successfully. Check your n8n workflow.</span>
                </div>
              )}

              {emailDraftError && (
                <div className="mb-4 p-3 border border-red-300 bg-red-50 rounded-lg text-red-800 flex items-center gap-2">
                  <Icon name="alert-circle" className="w-5 h-5 text-red-600" />
                  <span>{emailDraftError}</span>
                </div>
              )}

              <div className="bg-white rounded-lg shadow-md border border-pacifica-gray overflow-hidden mb-6">
                <div className="p-4 bg-gradient-to-r from-pacifica-navy to-pacifica-midnight">
                  <h2 className="text-lg font-semibold text-white">
                    Grades Table ({Object.values(grades).filter(g => g.completed).length}/{students.length} graded)
                  </h2>
                  <p className="text-xs text-pacifica-gray mt-1">Click any cell to edit • Press Tab/Enter to navigate • Decimals supported</p>
                </div>

                <div className="overflow-x-auto">
                  <table className="w-full border-collapse">
                    <thead className="bg-pacifica-gray bg-opacity-20 sticky top-0">
                      <tr>
                        <th
                          className={`px-4 py-3 text-left text-xs font-semibold text-pacifica-navy border-b-2 border-pacifica-gray sticky left-0 bg-pacifica-gray bg-opacity-20 z-10 cursor-pointer hover:bg-pacifica-orange hover:bg-opacity-20 ${selectedColumn === 0 ? 'bg-pacifica-orange bg-opacity-30' : ''}`}
                          onClick={() => {
                            setSelectedColumn(selectedColumn === 0 ? null : 0);
                            setSelectedRow(null);
                            setSelectedCell(null);
                          }}
                        >
                          Student
                        </th>
                        {rubricItems.map((item, idx) => (
                          <th
                            key={idx}
                            className={`px-4 py-3 text-center text-xs font-semibold text-pacifica-navy border-b-2 border-pacifica-gray min-w-[120px] cursor-pointer hover:bg-pacifica-orange hover:bg-opacity-20 ${selectedColumn === idx + 1 ? 'bg-pacifica-orange bg-opacity-30' : ''}`}
                            onClick={() => {
                              setSelectedColumn(selectedColumn === idx + 1 ? null : idx + 1);
                              setSelectedRow(null);
                              setSelectedCell(null);
                            }}
                          >
                            <div>{item.name}</div>
                            <div className="text-xs font-normal text-pacifica-slate">(/{item.maxPoints})</div>
                          </th>
                        ))}
                        <th
                          className={`px-4 py-3 text-center text-xs font-semibold text-pacifica-navy border-b-2 border-pacifica-gray min-w-[100px] cursor-pointer hover:bg-pacifica-orange hover:bg-opacity-20 ${selectedColumn === rubricItems.length + 1 ? 'bg-pacifica-orange bg-opacity-30' : ''}`}
                          onClick={() => {
                            setSelectedColumn(selectedColumn === rubricItems.length + 1 ? null : rubricItems.length + 1);
                            setSelectedRow(null);
                            setSelectedCell(null);
                          }}
                        >
                          Total
                        </th>
                        <th
                          className={`px-4 py-3 text-left text-xs font-semibold text-pacifica-navy border-b-2 border-pacifica-gray min-w-[300px] cursor-pointer hover:bg-pacifica-orange hover:bg-opacity-20 ${selectedColumn === rubricItems.length + 2 ? 'bg-pacifica-orange bg-opacity-30' : ''}`}
                          onClick={() => {
                            setSelectedColumn(selectedColumn === rubricItems.length + 2 ? null : rubricItems.length + 2);
                            setSelectedRow(null);
                            setSelectedCell(null);
                          }}
                        >
                          Comments
                        </th>
                      </tr>
                    </thead>
                    <tbody>
                      {sortedStudentsForResults.map((student, rowIdx) => {
                        const sg = student.grade;
                        const isSelected = selectedCell?.row === rowIdx;

                        return (
                          <tr
                            key={student.id}
                            className={`border-b border-pacifica-gray hover:bg-pacifica-orange hover:bg-opacity-5 ${sg.completed ? 'bg-green-50 bg-opacity-50' : ''} ${selectedRow === rowIdx ? 'bg-pacifica-orange bg-opacity-20' : isSelected ? 'bg-pacifica-orange bg-opacity-10' : ''}`}
                          >
                            <td
                              className={`px-4 py-3 sticky left-0 bg-white border-r border-pacifica-gray cursor-pointer hover:bg-pacifica-orange hover:bg-opacity-20 ${selectedRow === rowIdx ? 'bg-pacifica-orange bg-opacity-30' : selectedColumn === 0 ? 'bg-pacifica-orange bg-opacity-15' : ''}`}
                              onClick={() => {
                                setSelectedRow(selectedRow === rowIdx ? null : rowIdx);
                                setSelectedColumn(null);
                                setSelectedCell(null);
                              }}
                            >
                              <div className="flex items-center gap-2">
                                <div className={`w-8 h-8 rounded-full flex items-center justify-center text-xs font-semibold ${sg.completed ? 'bg-green-600 text-white' : 'bg-pacifica-gray text-pacifica-navy'}`}>
                                  {sg.completed ? '✓' : getInitials(student.name)}
                                </div>
                                <div className="min-w-0">
                                  <p className="font-medium text-sm text-pacifica-navy truncate">{student.name}</p>
                                  <p className="text-xs text-pacifica-slate">{student.studentId}</p>
                                </div>
                              </div>
                            </td>

                            {rubricItems.map((item, colIdx) => {
                              const score = sg.scores[item.name];
                              const cellSelected = selectedCell?.row === rowIdx && selectedCell?.col === colIdx;

                              return (
                                <td
                                  key={colIdx}
                                  className={`px-2 py-2 text-center border-r border-pacifica-gray ${cellSelected ? 'bg-pacifica-orange bg-opacity-20' : selectedColumn === colIdx + 1 ? 'bg-pacifica-orange bg-opacity-15' : selectedRow === rowIdx ? 'bg-pacifica-orange bg-opacity-15' : 'hover:bg-gray-50'}`}
                                  onClick={() => setSelectedCell({ row: rowIdx, col: colIdx })}
                                >
                                  <div
                                    contentEditable={true}
                                    suppressContentEditableWarning={true}
                                    onFocus={(e) => {
                                      const range = document.createRange();
                                      range.selectNodeContents(e.target);
                                      const sel = window.getSelection();
                                      sel.removeAllRanges();
                                      sel.addRange(range);
                                    }}
                                    onBlur={(e) => {
                                      const text = e.target.textContent.trim();
                                      const val = text === '' || text === '-' ? 0 : parseFloat(text);

                                      if (!isNaN(val) && val >= 0 && val <= item.maxPoints) {
                                        setGrades(prev => ({
                                          ...prev,
                                          [student.id]: {
                                            ...prev[student.id],
                                            scores: {
                                              ...prev[student.id]?.scores,
                                              [item.name]: val
                                            }
                                          }
                                        }));
                                        e.target.textContent = val;
                                      } else {
                                        e.target.textContent = score !== undefined && score !== null ? score : '-';
                                      }
                                    }}
                                    onKeyDown={(e) => {
                                      if (e.key === 'Enter') {
                                        e.preventDefault();
                                        e.target.blur();
                                        if (rowIdx < sortedStudentsForResults.length - 1) {
                                          setSelectedCell({ row: rowIdx + 1, col: colIdx });
                                          setTimeout(() => {
                                            const nextRow = e.target.closest('tr').nextElementSibling;
                                            if (nextRow) {
                                              const nextCell = nextRow.querySelectorAll('td')[colIdx + 1];
                                              if (nextCell) {
                                                const editableDiv = nextCell.querySelector('[contenteditable]');
                                                if (editableDiv) editableDiv.focus();
                                              }
                                            }
                                          }, 10);
                                        }
                                      } else if (e.key === 'Tab') {
                                        e.preventDefault();
                                        e.target.blur();
                                        if (colIdx < rubricItems.length - 1) {
                                          setSelectedCell({ row: rowIdx, col: colIdx + 1 });
                                          setTimeout(() => {
                                            const row = e.target.closest('tr');
                                            const nextCell = row.querySelectorAll('td')[colIdx + 2];
                                            if (nextCell) {
                                              const editableDiv = nextCell.querySelector('[contenteditable]');
                                              if (editableDiv) editableDiv.focus();
                                            }
                                          }, 10);
                                        } else if (rowIdx < sortedStudentsForResults.length - 1) {
                                          setSelectedCell({ row: rowIdx + 1, col: 0 });
                                        }
                                      } else if (e.key === 'Escape') {
                                        e.target.blur();
                                        e.target.textContent = score !== undefined && score !== null ? score : '-';
                                      } else if (!/[\d.\-]/.test(e.key) && !['Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
                                        e.preventDefault();
                                      }
                                    }}
                                    className="min-h-[32px] px-2 py-1 text-base font-semibold text-pacifica-navy focus:outline-none focus:ring-2 focus:ring-pacifica-orange rounded cursor-text"
                                  >
                                    {score !== undefined && score !== null ? score : '-'}
                                  </div>
                                </td>
                              );
                            })}

                            <td className="px-4 py-3 text-center border-r border-pacifica-gray bg-pacifica-gray bg-opacity-10">
                              <div className="text-xl font-bold text-pacifica-navy">
                                {sg.completed ? student.total : '-'}
                              </div>
                              <div className="text-xs text-pacifica-slate">/{calculateMaxTotal()}</div>
                            </td>

                            <td
                              className="px-4 py-2 text-left"
                              onClick={() => setSelectedCell({ row: rowIdx, col: -2 })}
                            >
                              <div
                                contentEditable={true}
                                suppressContentEditableWarning={true}
                                onBlur={(e) => {
                                  const text = e.target.textContent.trim();
                                  setGrades(prev => ({
                                    ...prev,
                                    [student.id]: {
                                      ...prev[student.id],
                                      comments: text
                                    }
                                  }));
                                }}
                                onKeyDown={(e) => {
                                  if (e.key === 'Escape') {
                                    e.target.blur();
                                    e.target.textContent = sg.comments || '';
                                  }
                                }}
                                className="min-h-[32px] px-2 py-1 text-sm text-pacifica-navy focus:outline-none focus:ring-2 focus:ring-pacifica-orange rounded cursor-text"
                                placeholder="Click to add comments..."
                              >
                                {sg.comments || ''}
                              </div>
                            </td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </div>
              </div>

              <div className="bg-white rounded-lg shadow-md border border-pacifica-gray p-6 mb-6">
                <div className="flex flex-col gap-3 md:flex-row md:items-center md:justify-between mb-4">
                  <div>
                    <h2 className="text-lg font-semibold text-pacifica-navy">Choose Students for Email Drafts</h2>
                    <p className="text-sm text-pacifica-slate">Only graded students can receive an email draft.</p>
                  </div>
                  <div className="flex flex-wrap gap-2">
                    <button
                      type="button"
                      onClick={selectAllEmailRecipients}
                      className="btn btn-outline"
                      disabled={students.filter(s => grades[s.id]?.completed).length === 0}
                    >
                      Select All Graded
                    </button>
                    <button
                      type="button"
                      onClick={clearEmailRecipients}
                      className="btn btn-outline"
                      disabled={selectedEmailStudentIds.length === 0}
                    >
                      Clear Selection
                    </button>
                  </div>
                </div>
                <div className="grid gap-3 sm:grid-cols-2 xl:grid-cols-3">
                  {students.map(student => {
                    const gradeRecord = grades[student.id] || {};
                    const graded = !!gradeRecord.completed;
                    const totalScore = graded
                      ? rubricItems.reduce((sum, item) => sum + (gradeRecord.scores?.[item.name] || 0), 0)
                      : null;
                    const checked = graded && selectedEmailStudentIds.includes(student.id);
                    return (
                      <label
                        key={student.id}
                        className={`flex items-center justify-between gap-3 border rounded-lg px-4 py-3 transition ${graded
                          ? checked
                            ? 'border-pacifica-orange bg-pacifica-orange/10 shadow-sm'
                            : 'border-pacifica-gray hover:border-pacifica-orange hover:bg-pacifica-orange/10'
                          : 'border-pacifica-gray bg-gray-50 opacity-60 cursor-not-allowed'
                          }`}
                      >
                        <div className="min-w-0">
                          <p className="font-semibold text-pacifica-navy truncate">{student.name}</p>
                          <p className="text-xs text-pacifica-slate truncate">
                            {graded
                              ? `Graded • ${totalScore}/${maxTotal}`
                              : 'Not graded yet'}
                          </p>
                        </div>
                        <input
                          type="checkbox"
                          className="w-5 h-5 text-pacifica-orange rounded"
                          disabled={!graded}
                          checked={checked}
                          onChange={() => handleEmailRecipientToggle(student.id)}
                        />
                      </label>
                    );
                  })}
                </div>
              </div>

              <div className="mt-6 bg-white rounded-lg shadow-md border border-pacifica-gray p-6">
                <h2 className="text-lg font-semibold text-pacifica-navy mb-4">Recording Segments ({recordingSegments.length})</h2>
                {recordingSegments.length === 0 ? (
                  <p className="text-sm text-pacifica-gray italic">No recordings available.</p>
                ) : (
                  <div>
                    <div className="flex items-center justify-between mb-4">
                      <p className="text-sm text-pacifica-slate">{recordingSegments.length} recording(s) available for download</p>
                      <button
                        onClick={downloadAllRecordings}
                        className="px-4 py-2 bg-pacifica-orange text-white rounded-lg hover:bg-pacifica-tangerine flex items-center gap-2"
                      >
                        <Icon name="download" className="w-4 h-4" />
                        Download All as Zip
                      </button>
                    </div>
                    <div className="grid grid-cols-4 gap-3">
                      {recordingSegments.map((segment) => (
                        <div
                          key={segment.id}
                          onClick={() => {
                            const recording = completedRecordingsRef.current.find(r => r.id === segment.id);
                            if (recording) downloadRecording(recording);
                          }}
                          className={`p-3 rounded-lg border cursor-pointer transition-all hover:shadow-md ${segment.status === 'completed' ? 'bg-green-50 border-green-300' :
                            segment.status === 'processing' ? 'bg-pacifica-canary bg-opacity-20 border-pacifica-canary' :
                              segment.status === 'error' ? 'bg-red-50 border-red-300' :
                                'bg-pacifica-gray bg-opacity-20 border-pacifica-gray'
                            }`}
                          title="Click to download"
                        >
                          <div className="flex items-center gap-2">
                            <Icon name="file-audio" className="w-4 h-4" />
                            <div className="flex-1 min-w-0">
                              <p className="text-sm font-semibold truncate text-pacifica-navy">
                                {segment.studentName || `Segment ${segment.chunkNumber}`}
                              </p>
                              <p className="text-xs text-pacifica-slate">
                                {(segment.duration / 1000).toFixed(1)}s • {Math.round(segment.size / 1024)}KB
                              </p>
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            </div >
          </div >
        );
      }

      return (
        <div className="min-h-screen bg-white p-6 flex items-center justify-center">
          <div className="bg-white rounded-lg shadow-xl p-8 max-w-md">
            <h2 className="text-xl font-bold text-pacifica-navy mb-4">Unknown Step: {step}</h2>
            <p className="text-pacifica-slate mb-4">Something went wrong. Current step is: "{step}"</p>
            <button
              onClick={() => {
                console.log('Resetting to teacher-select');
                setStep('teacher-select');
                setSelectedTeacher(null);
                setSelectedSections([]);
                setStudents([]);
                setGrades({});
                setTranscript([]);
                setRecordingSegments([]);
                completedRecordingsRef.current = [];
                setUploadComplete(false);
                setAssignmentName('');
                setSessionId(null);
                manualTranscriptRequestsRef.current.clear();
                setManualTranscriptText('');
                setManualTranscriptError(null);
                setShowManualTranscriptInput(false);
                setIsSubmittingTranscript(false);
                setPendingCount(0);
              }}
              className="w-full px-4 py-2 bg-pacifica-orange text-white font-semibold rounded-lg hover:bg-pacifica-tangerine"
            >
              Return to Start
            </button>
          </div>
        </div>
      );
    }

    ReactDOM.render(<GradingInterface />, document.getElementById('root'));
  </script>
</body>

</html>